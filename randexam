#!/usr/bin/env python

######################################################################
######################################################################

# Configuration Section

N_e = 25 # number of randomized exams
N_A = 5 # maximum number of answers per question
LAST_SCANTRON_QUESTION_NUMBER = 96

RANDOM_SEED = 7

######################################################################
######################################################################

LIBRARY_FILENAME = "library.tex"
SCANTRON_FILENAME = "scantron.dat"
EXAMS_FILENAME = "exams.tex"
SOLUTIONS_FILENAME = "solutions.csv"
SPECS_FILENAME = "specs.csv"
POINTS_FILENAME = "points.csv"
ANSWERS_FILENAME = "answers.csv"
GRADES_FILENAME = "grades.csv"
STATS_PREFIX = "stats"

######################################################################
######################################################################

import re, random, sys, itertools, string, csv, os
import numpy as np

def main():
    if len(sys.argv) != 2:
        print("usage: %s <command>" % sys.argv[0])
        print("")
        print("<command> is:")
        print("   proc-lib     process the library and generate exams")
        print("   proc-scan    process and unscramble the scantron file")
        print("   proc-ans     process the answer file to produce grades")
        sys.exit(0)

    if sys.argv[1] == "proc-lib":
        for filename in [SPECS_FILENAME, EXAMS_FILENAME, SOLUTIONS_FILENAME]:
            if os.path.exists(filename):
                print("ERROR: %s already exists, will not overwrite" % filename)
                sys.exit(1)
        random.seed(RANDOM_SEED)
        library = read_library(LIBRARY_FILENAME)
        check_library(library)
        (P, C) = extract_points(library, N_A)
        write_points(POINTS_FILENAME, P)
        (K, Q, V, A) = generate_specs(library, N_e, N_A)
        check_key_distances(K)
        write_specs(SPECS_FILENAME, K, Q, V, A)
        write_exams(EXAMS_FILENAME, library, K, Q, V, A)
        write_solutions(SOLUTIONS_FILENAME, library, K, Q, V, C)
    elif sys.argv[1] == "proc-scan":
        (K, Q, V, A) = read_specs(SPECS_FILENAME)
        N_Q = Q.shape[1]
        (u, k, a) = read_scantrons(SCANTRON_FILENAME, N_e, N_Q, N_A)
        write_answers(ANSWERS_FILENAME, u, k, a)
    elif sys.argv[1] == "proc-ans":
        (K, Q, V, A) = read_specs(SPECS_FILENAME)
        (u, k, a) = read_answers(ANSWERS_FILENAME)
        P = read_points(POINTS_FILENAME)
        (P_seq, P_se, P_sq, P_s, P_sQ) = generate_grades(P, K, Q, V, A, u, k, a, warnings=True)
        write_grades(GRADES_FILENAME, u, P_s)
        generate_and_write_statistics(STATS_PREFIX, P, K, Q, V, A, u, k, a)
    else:
        print("ERROR: unrecognized command: %s" % sys.argv[1])
        print("valid commands are \"proc-lib\", \"proc-scan\", or \"proc-ans\"")

######################################################################
######################################################################

class Library:
    def __init__(self):
        self.coverpage = ""
        self.zones = []

class Zone:
    def __init__(self):
        self.body = ""
        self.questions = []

class Question:
    def __init__(self):
        self.variants = []
        self.line_number = None
        self.scantron_uses = 0
        self.scantron_answers = 0
        self.scantron_points = 0

class Variant:
    def __init__(self):
        self.body = ""
        self.answers = []
        self.line_number = None
        self.scantron_uses = 0
        self.scantron_answers = 0
        self.scantron_points = 0

class Answer:
    def __init__(self):
        self.body = ""
        self.correct = False
        self.line_number = None
        self.points = 0
        self.scantron_answers = 0

class LibraryRegexp:
    def __init__(self, name, regexp, no_tail=False):
        self.name = name
        self.regexp = regexp
        self.no_tail = no_tail

class ReadState:
    def __init__(self):
        self.name = "start"
        self.zone = Zone()
        self.question = Question()
        self.variant = Variant()
        self.answer = Answer()

######################################################################
######################################################################

def ind2chr(index):
    """c = ind2chr(i)

    Convert the index i to a character c, so that 0 -> 'A', 1 -> 'B',
    etc. Invalid indexes convert to the character '*'.
    """
    index = int(index)
    if index < 0 or index >= len(string.ascii_uppercase):
        return "*"
    return string.ascii_uppercase[index]

def chr2ind(char):
    """i = ind2chr(c)

    Convert the character c to an index i, so that 'A' -> 0, 'B' -> 1,
    etc. Uppercase and lowercase are both converted. Invalid
    characters convert to -1.
    """
    if char in string.ascii_uppercase:
        return string.ascii_uppercase.index(char)
    if char in string.ascii_lowercase:
        return string.ascii_lowercase.index(char)
    return -1

######################################################################
######################################################################

def read_library(input_filename):
    try:
        input_file = open(input_filename, "r")
    except Exception as e:
        print("ERROR: Unable to open library file for reading: %s: %s" % (input_filename, e))
        sys.exit(1)
    library_regexps = [
        LibraryRegexp(name="begin_document", regexp=r"^\s*\\begin\{document\}(.*)$", no_tail=True),
        LibraryRegexp(name="zone", regexp=r"^\s*\\zone(.*)$", no_tail=True),
        LibraryRegexp(name="question", regexp=r"^\s*\\question(.*)$", no_tail=True),
        LibraryRegexp(name="variant", regexp=r"^\s*\\variant(.*)$", no_tail=True),
        LibraryRegexp(name="begin_answers", regexp=r"^\s*\\begin\{answers\}(.*)$", no_tail=True),
        LibraryRegexp(name="answer", regexp=r"^\s*\\answer(.*)$"),
        LibraryRegexp(name="correct_answer", regexp=r"^\s*\\correctanswer(.*)$"),
        LibraryRegexp(name="end_answers", regexp=r"^\s*\\end\{answers\}(.*)$", no_tail=True),
        LibraryRegexp(name="end_document", regexp=r"^\s*\\end\{document\}(.*)$", no_tail=True),
        LibraryRegexp(name="text", regexp=r"^.*\S.*$"),
        LibraryRegexp(name="blank", regexp=r"^\s*$"),
        ]
    library = Library()
    state = ReadState()
    for (i_line, line) in enumerate(input_file):
        def log(msg):
            print("%s:%d: %s" % (input_filename, i_line + 1, msg))
        def error(msg):
            print("%s:%d: ERROR: %s" % (input_filename, i_line + 1, msg))
            sys.exit(1)
        line = line.strip()
        log("read line: \"%s\"" % line)
            
        match_comment = re.search(r"(?<!\\)%", line)
        if match_comment:
            line = line[:match_comment.start()]
            log("stripped comments: \"%s\"" % line)
        match_name = None
        match = None
        for library_regexp in library_regexps:
            match = re.match(library_regexp.regexp, line)
            if match:
                match_name = library_regexp.name
                if library_regexp.no_tail:
                    extra_text = match.group(1).strip()
                    if len(extra_text) > 0:
                        error("invalid extra text following '%s': %s", match_name, extra_text)
                break
        else:
            error("no matches found")
            continue
        log("found match '%s'" % match_name)

        def transition(new_state_name):
            log(r"state transition: '%s' -> '%s'" % (state.name, new_state_name))
            state.name = new_state_name
        def bad_transition():
            error("'%s' not allowed in state '%s'" % (match_name, state.name))
        def new_zone():
            log("starting new zone")
            state.zone = Zone()
            library.zones.append(state.zone)
            state.zone.line_number = i_line + 1
        def new_question():
            log("starting new question")
            state.question = Question()
            state.zone.questions.append(state.question)
            state.question.line_number = i_line + 1
        def new_variant():
            log("starting new variant")
            state.variant = Variant()
            state.question.variants.append(state.variant)
            state.variant.line_number = i_line + 1
        def new_answer(correct):
            log("starting new answer")
            state.answer = Answer()
            state.variant.answers.append(state.answer)
            state.answer.line_number = i_line + 1
            state.answer.body = match.group(1)
            state.answer.correct = correct
        def append_to_coverpage():
            log("appending line to coverpage")
            if len(library.coverpage) > 0:
                library.coverpage += "\n"
            library.coverpage += line
        def append_to_zone_body():
            log("appending line to zone body")
            if len(state.zone.body) > 0:
                state.zone.body += "\n"
            state.zone.body += line
        def append_to_variant_body():
            log("appending line to variant body")
            if len(state.variant.body) > 0:
                state.variant.body += "\n"
            state.variant.body += line
        def append_to_answer_body():
            log("appending line to answer body")
            if len(state.answer.body) > 0:
                state.answer.body += "\n"
            state.answer.body += line

        if state.name == "start":
            if match_name == "begin_document":   transition("coverpage")
            elif match_name == "text":           log("skipping text line")
            elif match_name == "blank":          log("skipping blank line")
            else: bad_transition()
        elif state.name == "coverpage":
            if match_name == "text":             append_to_coverpage()
            elif match_name == "blank":          append_to_coverpage()
            elif match_name == "zone":           transition("zone"); new_zone()
            else: bad_transition()
        elif state.name == "zone":
            if match_name == "text":             append_to_zone_body()
            elif match_name == "blank":          append_to_zone_body()
            elif match_name == "question":       transition("question"); new_question()
            elif match_name == "zone":           transition("zone"); new_zone()
            elif match_name == "end_document":   log("stopping file reading"); break
            else: bad_transition()
        elif state.name == "question":
            if match_name == "variant":          transition("variant"); new_variant()
            elif match_name == "question":       transition("question"); new_question()
            elif match_name == "zone":           transition("zone"); new_zone()
            elif match_name == "end_document":   log("stopping file reading"); break
            elif match_name == "blank":          log("skipping blank line")
            else: bad_transition()
        elif state.name == "variant":
            if match_name == "text":             append_to_variant_body()
            elif match_name == "blank":          append_to_variant_body()
            elif match_name == "begin_answers":  transition("answers")
            else: bad_transition()
        elif state.name == "answers":
            if match_name == "correct_answer":   transition("answer"); new_answer(correct=True)
            elif match_name == "answer":         transition("answer"); new_answer(correct=False)
            elif match_name == "blank":          log("skipping blank line")
            else: bad_transition()
        elif state.name == "answer":
            if match_name == "text":             append_to_answer_body()
            elif match_name == "blank":          append_to_answer_body()
            elif match_name == "correct_answer": transition("answer"); new_answer(correct=True)
            elif match_name == "answer":         transition("answer"); new_answer(correct=False)
            elif match_name == "end_answers":    transition("question")
            else: bad_transition()
        else:
            error("unknown state '%s'", state.name)

    input_file.close()
    return library

def check_library(library):
    errors = []
    if len(library.zones) == 0:
        errors.append("ERROR: no zones")
    print("For each question variant listed below, V#-S#-# shows:")
    print("  variant number - number of answers - correct answer letter")
    for (i_zone, zone) in enumerate(library.zones):
        print("Zone %d: %d questions" % (i_zone + 1, len(zone.questions)))
        for (i_question, question) in enumerate(zone.questions):
            variant_infos = []
            if len(question.variants) == 0:
                errors.append("ERROR: question %d (line %d): no variants"
                              % (i_question + 1, question.line_number))
            for (i_variant, variant) in enumerate(question.variants):
                if len(variant.body) == 0:
                    errors.append("ERROR: question %d, variant %d (line %d): no body text"
                                  % (i_question + 1, i_variant + 1, variant.line_number))
                if len(variant.answers) < 2:
                    errors.append("ERROR: question %d, variant %d (line %d): less than 2 answers"
                                  % (i_question + 1, i_variant + 1, variant.line_number))
                correct_answer_indexes = []
                for (i_answer, answer) in enumerate(variant.answers):
                    if len(answer.body) == 0:
                        errors.append("ERROR: question %d, variant %d, answer %d (line %d): no body text"
                                      % (i_question + 1, i_variant + 1, i_answer + 1, answer.line_number))
                    if answer.correct:
                        correct_answer_indexes.append(i_answer)
                if len(correct_answer_indexes) == 0:
                    errors.append("ERROR: question %d, variant %d (line %d): no correct answer"
                                  % (i_question + 1, i_variant + 1, variant.line_number))
                if len(correct_answer_indexes) > 1:
                    errors.append("ERROR: question %d, variant %d (line %d): more than one correct answer"
                                  % (i_question + 1, i_variant + 1, variant.line_number))
                variant_infos.append("V%d-S%d-%s"
                                     % (i_variant + 1, len(variant.answers),
                                        "".join([ind2chr(i) for i in correct_answer_indexes])))
            print("    Question %d: %s" % (i_question + 1, ", ".join(variant_infos)))
    if len(errors) > 0:
        for error in errors:
            print(error)
        sys.exit(1)

######################################################################
######################################################################

def extract_points(library, N_A):
    """(P, C) = extract_points(library, N_A)

    Extract the correct solutions and points from the library.
    Returns:

    P[Q,V,A] = points for answer A of variant V of library question Q
    C[Q,V] = the correct answer for variant V of library question Q
    """
    flat_questions = list(itertools.chain.from_iterable([zone.questions for zone in library.zones]))
    N_Q = len(flat_questions)
    N_V = max([len(q.variants) for q in flat_questions])

    P = np.zeros((N_Q, N_V, N_A), dtype=float)
    C = np.zeros((N_Q, N_V), dtype=str)

    for Qi in range(N_Q):
        for Vi in range(N_V):
            for Ai in range(N_A):
                if Vi < len(flat_questions[Qi].variants):
                    if Ai < len(flat_questions[Qi].variants[Vi].answers):
                        if flat_questions[Qi].variants[Vi].answers[Ai].correct:
                            C[Qi,Vi] = ind2chr(Ai)
                            P[Qi,Vi,Ai] = 1
    return (P, C)

def write_points(output_filename, P):
    (N_Q, N_V, N_A) = P.shape
    with open(output_filename, 'w') as out_f:
        writer = csv.writer(out_f)
        writer.writerow(["Q", "V", "A", "P(Q,V,A)"])
        for Qi in range(N_Q):
            for Vi in range(N_V):
                for Ai in range(N_A):
                    writer.writerow([Qi + 1, Vi + 1, ind2chr(Ai), P[Qi,Vi,Ai]])

def read_points(input_filename):
    Q_data = []
    V_data = []
    A_data = []
    P_data = []
    with open(input_filename, "r") as in_f:
        reader = csv.reader(in_f)
        for (i_row, row) in enumerate(reader):
            if i_row == 0:
                continue # skip header
            if len(row) != 4:
                print("%s:%d: ERROR: expected 4 entries but got %d"
                      % (input_filename, i_row + 1, len(row)))
                sys.exit(1)
            try:
                Q_data.append(int(row[0]) - 1)
                V_data.append(int(row[1]) - 1)
                A_data.append(chr2ind(row[2]))
                P_data.append(float(row[3]))
            except Exception as e:
                print("%s:%s: ERROR: %s" % (input_filename, i_row + 1, e))
                sys.exit(1)
    N_Q = max(Q_data) + 1
    N_V = max(V_data) + 1
    N_A = max(A_data) + 1
    P = np.array(P_data, dtype=float).reshape((N_Q, N_V, N_A))
    return P

######################################################################
######################################################################

def generate_specs(library, N_e, N_A):
    """(K, Q, V, A) = generate_specs(library, N_e)

    K[e] = exam key
    Q[e,q] = library question number for exam e, question q
    V[e,q] = library variant number for exam e, question q
    A[e,q,a] = library answer number for exam e, question q, answer a
    """
    flat_questions = list(itertools.chain.from_iterable([zone.questions for zone in library.zones]))
    N_Q = len(flat_questions)
    N_V = max([len(q.variants) for q in flat_questions])

    K = np.empty(N_e, dtype=object)
    Q = np.zeros((N_e, N_Q), dtype=int)
    V = np.zeros((N_e, N_Q), dtype=int)
    A = np.zeros((N_e, N_Q, N_A), dtype=str)

    # generate N_e random exams
    for ei in range(N_e):
        K[ei] = generate_key(ei, N_e, N_A)

        # randomize question order within each zone
        q_list = []
        Qi = 0
        for (i_zone, zone) in enumerate(library.zones):
            q_zone = list(range(Qi, (Qi + len(zone.questions))))
            random.shuffle(q_zone)
            q_list.extend(q_zone)
            Qi += len(zone.questions)
        Q[ei,:] = np.array(q_list)

        # choose random variant for each question and randomize answer order
        for qi in range(N_Q):
            question = flat_questions[Q[ei,qi]]
            V[ei,qi] = random.randrange(len(question.variants))
            a_list = list(range(len(question.variants[V[ei,qi]].answers)))
            random.shuffle(a_list)
            A[ei,qi,:] = np.array([ind2chr(i) for i in a_list])

    return (K, Q, V, A)

def write_specs(output_filename, K, Q, V, A):
    (N_e, N_Q) = Q.shape
    with open(output_filename, 'w') as out_f:
        writer = csv.writer(out_f)
        row = ["e", "K(e)"]
        for qi in range(N_Q):
            row.extend(["Q(e,q=%d)" % (qi + 1), "V(e,q=%d)" % (qi + 1), "A(e,q=%d,:)" % (qi + 1)])
        writer.writerow(row)
        for ei in range(N_e):
            row = [ei + 1, K[ei]]
            for qi in range(N_Q):
                row.extend([Q[ei,qi] + 1, V[ei,qi] + 1, "".join(A[ei,qi,:])])
            writer.writerow(row)

def read_specs(input_filename):
    K_data = []
    Q_data = []
    V_data = []
    A_data = []
    with open(input_filename, "r") as in_f:
        reader = csv.reader(in_f)
        for (i_row, row) in enumerate(reader):
            if i_row == 0:
                continue # skip header
            if (len(row) - 2) % 3 != 0:
                print("%s:%d: ERROR: expected 3N+2 items in row, got %d"
                      % (input_filename, i_row + 1, len(row)))
                sys.exit(1)
            K_data.append(row[1])
            data = np.array(row[2:], dtype=object).reshape((-1, 3))
            Q_data.append([int(d) - 1 for d in data[:,0]])
            V_data.append([int(d) - 1 for d in data[:,1]])
            A_data.append([list(d) for d in data[:,2]])
    K = np.array(K_data, dtype=object)
    Q = np.array(Q_data, dtype=int)
    V = np.array(V_data, dtype=int)
    A = np.array(A_data, dtype=str)
    return (K, Q, V, A)

######################################################################
######################################################################

def generate_key(e, N_e, N_A):
    """K = generate_key(e, N_e, N_A)
    
    Generates a key for exam number e of N_e total exams.

    The key is a base-N_A encoding of the exam number with 2 or 3
    checksum digits appended.

    check1 is just a parity check
    check2 is a Fletcher checksum
    check3 is a modified Fletcher checksum
    A minimum Hamming distance of 3 between keys is guaranteed by:
      check1 and check2 for n_digits <= (N_A - 1)
      all three checksums for n_digits <= (N_A - 1)^2
    """
    for n_digits in range(10):
        if N_A**n_digits >= N_e:
            break
    else:
        raise Exception("too many exam variants to determine n_digits")
    key_array = []
    check1 = 3 % N_A # shift to avoid "AA" having check "A"
    check2 = 2 % N_A
    check3 = 4 % N_A
    for i in range(n_digits):
        d = (e // N_A**i) % N_A
        key_array.append(d)
        check1 = (check1 + d) % N_A
        check2 = (check2 + (i % (N_A - 1) + 1) * d) % N_A
        check3 = (check3 + (i // (N_A - 1) % (N_A - 1) + 1) * d) % N_A
    key_array.append(check1)
    key_array.append(check2)
    if (n_digits > N_A - 1):
        key_array.append(check3)
    key = "".join([["A", "B", "C", "D", "E"][i] for i in key_array]);
    return key

def hamming_distance(Ki, Kj):
    """Computes the Hamming distance between keys Ki and Kj.

    >>> hamming_distance("ABC", "AEC")
    1
    """
    if len(Ki) != len(Kj):
        raise Exception("cannot compute Hamming distance for keys "
                        + "of different lengths: %s, %s" % (Ki, Kj))
    different_indexes = [i for i in range(len(Ki)) if Ki[i] != Kj[i]]
    return len(different_indexes)

def check_key_distances(K):
    """Checks that the keys are all distinct and prints the
    minimum Hamming distance between keys.
    """
    N_e = K.shape[0]
    if N_e < 1:
        return
    min_d = len(K[0])
    for ei in range(N_e):
        for ej in range(ei):
            if K[ei] == K[ej]:
                raise Exception("duplicate key %s found" % K[ei])
            min_d = min(min_d, hamming_distance(K[ei], K[ej]))
    print("Minimum Hamming distance between keys: %d" % min_d)

######################################################################
######################################################################

def write_exams(output_filename, library, K, Q, V, A):
    (N_e, N_Q, N_A) = A.shape

    flat_questions = list(itertools.chain.from_iterable([zone.questions for zone in library.zones]))
    with open(output_filename, "w") as out_f:
        out_f.write(r"\documentclass[twoside]{article}" + "\n")
        out_f.write(r"\usepackage{amsmath,amssymb}" + "\n")
        out_f.write(r"\usepackage[margin=3cm]{geometry}" + "\n")
        out_f.write(r"\usepackage{graphicx}" + "\n")
        out_f.write(r"\begin{document}" + "\n")

        for ei in range(N_e):
            out_f.write(("%" * 70 + "\n") * 4)
            out_f.write(r"\newpage" + "\n\n")
            out_f.write(r"\setcounter{page}{1}")
            out_f.write(library.coverpage + "\n")
            out_f.write(r"\begin{enumerate}" + "\n")
            for (i_key_digit, key_digit) in enumerate(K[ei]):
                key_question = LAST_SCANTRON_QUESTION_NUMBER - len(K[ei]) + i_key_digit + 1
                out_f.write(r"\item[%d.] %s" % (key_question, key_digit) + "\n")
            out_f.write(r"\end{enumerate}" + "\n\n")
            out_f.write(r"\newpage" + "\n\n")

            qi = 0
            for (i_zone, zone) in enumerate(library.zones):
                out_f.write("%% Zone %d\n\n" % (i_zone + 1))
                out_f.write(zone.body + "\n\n")
                for i_zone_question in range(len(zone.questions)):
                    out_f.write(r"\vspace{10em}" + "\n")
                    out_f.write(r"\noindent" + "\n")
                    out_f.write(r"\begin{minipage}{\textwidth}" + "\n")
                    out_f.write(r"%d." % (qi + 1) + "\n")
                    variant = flat_questions[Q[ei,qi]].variants[V[ei,qi]]
                    out_f.write(variant.body + "\n")
                    out_f.write(r"\begin{enumerate}" + "\n")
                    for ai in range(N_A):
                        out_f.write(r"\item[(%s)]" % ind2chr(ai) + "\n")
                        out_f.write(variant.answers[chr2ind(A[ei,qi,ai])].body + "\n")
                    out_f.write(r"\end{enumerate}" + "\n")
                    out_f.write(r"\end{minipage}" + "\n\n")
                    qi += 1

        out_f.write(r"\cleardoublepage" + "\n")
        out_f.write(r"\end{document}" + "\n")

######################################################################
######################################################################

def write_solutions(output_filename, library, K, Q, V, C):
    (N_e, N_Q) = Q.shape

    with open(output_filename, "w") as out_f:
        writer = csv.writer(out_f)
        writer.writerow(["e", "K(e)"] + ["C(e,q=%d)" % (q + 1) for q in range(N_Q)])
        for e in range(N_e):
            writer.writerow([e + 1, K[e]] + [C[Q[e,q], V[e,q]] for q in range(N_Q)])

######################################################################
######################################################################

def read_scantrons(input_filename, N_e, N_Q, N_A):
    key_length = len(generate_key(0, N_e, N_A))
    u_data = []
    k_data = []
    a_data = []
    def error_if_match(s, pattern, offset, field, min_length):
        if len(s) < min_length:
            raise Exception("field '%s' at character %d has length %d but must be at least %d: %s"
                            % (field, offset + 1, len(s), min_length, s))
        match = re.search(pattern, s)
        if match:
            i = match.start()
            raise Exception("invalid character '%s' at character %d at position %d in field '%s': %s"
                            % (s[i], i + offset + 1, i + 1, field, s))
        return s
    key_length = len(generate_key(0, N_e, N_A))
    with open(input_filename, "r") as in_f:
        for (i_line, line) in enumerate(in_f):
            if len(line) == 1 and ord(line[0]) == 26:
                # last line has a single char
                continue

            key_end = 72 + LAST_SCANTRON_QUESTION_NUMBER
            key_start = key_end - key_length

            if len(line) < key_end:
                print("%s:%d: ERROR: line length %d less than expected %d" \
                          % (input_filename, i_line + 1, len(line), key_end))
                sys.exit(1)

            try:
                last_name = error_if_match(line[40:50].strip(), "[^A-Z ]", 40, "Last Name", 1)
                first_initial = error_if_match(line[50:51].strip(), "[^A-Z]", 50, "First Initial", 1)
                student_number = error_if_match(line[51:60].strip(), "[^0-9]", 51, "Student Number", 9)
                section = error_if_match(line[60:63].strip(), "[^0-9]", 60, "Section", 0)
                network_id = error_if_match(line[63:71].strip(), "[^A-Z0-9]", 63, "Network ID", 1)
                test_form = error_if_match(line[71:71].strip(), "[^A-Z]", 71, "Test Form", 0)
                answers = error_if_match(line[72:72 + N_Q], "[^0-9]", 72, "Answers", 0)
                key = error_if_match(line[key_start:key_end], "[^0-9]", key_start, "Key", key_length)
            except Exception as e:
                print("%s:%d: ERROR: %s" % (input_filename, i_line + 1, e))
                sys.exit(1)

            answers = ["*" if c == " " else ind2chr(int(c) - 1)
                       for c in answers]
            key = "".join(["*" if c == " " else ind2chr(int(c) - 1)
                           for c in key])

            u_data.append([last_name, first_initial, student_number, network_id])
            k_data.append(key)
            a_data.append(list(answers))

    u = np.array(u_data, dtype=object)
    k = np.array(k_data, dtype=object)
    a = np.array(a_data, dtype=str)
    return (u, k, a)

def write_answers(output_filename, u, k, a):
    (N_s, N_Q) = a.shape
    with open(output_filename, 'w') as out_f:
        writer = csv.writer(out_f)
        writer.writerow(["s", "Name", "Initial", "Number", "NetID", "k(s)"]
                        + ["a(s,q=%d)" % (q + 1) for q in range(N_Q)])
        for si in range(N_s):
            writer.writerow([si + 1, u[si,0], u[si,1], u[si,2], u[si,3], k[si]]
                            + [a[si,qi] for qi in range(N_Q)])

def read_answers(input_filename):
    u_data = []
    k_data = []
    a_data = []
    with open(input_filename, "r") as in_f:
        reader = csv.reader(in_f)
        for (i_row, row) in enumerate(reader):
            if i_row == 0:
                continue # skip header
            if len(row) < 6:
                print("%s:%d: ERROR: expected at least 6 items in row, got %d"
                      (input_filename, i_row + 1, len(row)))
            u_data.append(row[1:5])
            k_data.append(row[5])
            a_data.append(row[6:])
    u = np.array(u_data, dtype=object)
    k = np.array(k_data, dtype=object)
    a = np.array(a_data, dtype=str)
    return (u, k, a)

######################################################################
######################################################################

def keys_to_exams(K, k, u):
    N_s = k.shape[0]
    e = np.zeros(N_s, dtype=int)
    for si in range(N_s):
        if k[si] not in K:
            print("WARNING: key %s for student %s/%s/%s/%s not found"
                  % (k[si], u[si,0], u[si,1], u[si,2], u[si,3]))
            e[si] = -1
        else:
            e[si] = np.argwhere(K == k[si])[0, 0]
    return e

def generate_grades(P, K, Q, V, A, u, k, a, warnings=False):
    (N_Q, N_V, N_A) = P.shape
    N_s = u.shape[0]
    N_e = K.shape[0]

    e = keys_to_exams(K, k, u)

    P_seq = np.zeros((N_s, N_e, N_Q))
    for si in range(N_s):
        for ei in range(N_e):
            for qi in range(N_Q):
                P_seq[si,ei,qi] = P[Q[ei,qi], V[ei,qi], chr2ind(A[ei,qi,chr2ind(a[si,qi])])]
    P_se = P_seq.sum(axis=2)
    
    P_sq = np.zeros((N_s, N_Q))
    P_sQ = np.zeros((N_s, N_Q))
    P_s = np.zeros(N_s)
    for si in range(N_s):
        P_s[si] = P_se[si,e[si]]
        for qi in range(N_Q):
            P_sq[si,qi] = P_seq[si,e[si],qi]
            P_sQ[si,Q[e[si],qi]] = P_seq[si,e[si],qi]

    if warnings:
        for si in range(N_s):
            best_e = P_se[si,:].argmax()
            if e[si] < 0:
                print("%s/%s/%s/%s: no valid key, best match is %s with %f points"
                      % (u[si,0], u[si,1], u[si,2], u[si,3], K[best_e], P_se[si,best_e]))
            else:
                if P_se[si,best_e] > P_se[si,e[si]]:
                    print("%s/%s/%s/%s got %f points with valid key %s, but best match is %s with %f points"
                          % (u[si,0], u[si,1], u[si,2], u[si,3], P_se[si,e[si]], K[e[si]], K[best_e], P_se[si,best_e]))

    return (P_seq, P_se, P_sq, P_s, P_sQ)

def write_grades(output_filename, u, P_s):
    N_s = u.shape[0]

    with open(output_filename, 'w') as out_f:
        writer = csv.writer(out_f)
        writer.writerow(["s", "Name", "Initial", "Number", "NetID", "P_s(s)"])
        for si in range(N_s):
            writer.writerow([si + 1, u[si,0], u[si,1], u[si,2], u[si,3], P_s[si]])

def write_csv(output_filename, headers, data, index_formats=None):
    """Write the given array as a CSV file.

    For 1D data there should be two headers, index and value. For nD
    data there should be n headers, with the last header containing a
    %d conversion character.

    An nD array is written with the first n - 1 indexes as rows, and
    the last index as the columns. Breaking this rule, a 1D array is
    written as a column.
    """
    if index_formats == None:
        index_formats = ["i"] * len(data.shape)
    def format_index(i, f):
        if f == "i":
            return i + 1
        elif f == "c":
            return ind2chr(i)
    with open(output_filename, "w") as out_f:
        writer = csv.writer(out_f)
        if len(data.shape) == 0:
            writer.writerow(header[0])
            writer.writerow(data[0])
        elif len(data.shape) == 1:
            assert(len(headers) == 2)
            writer.writerow(headers)
            for i in range(data.shape[0]):
                writer.writerow([format_index(i, index_formats[0]), data[i]])
        else:
            row = headers[:-1]
            for j in range(data.shape[-1]):
                row.append(headers[-1] % format_index(j, index_formats[-1]))
            writer.writerow(row)
            for index in np.ndindex(data.shape[:-1]):
                row = [format_index(index[i], index_formats[i])
                           for i in range(len(index))]
                for j in range(data.shape[-1]):
                    row.append(data[index + (j,)])
                writer.writerow(row)

def write_halfviz(output_filename, data, threshold):
    """Write a graph from the given data in halfviz format.

    The data array must be square and symmetric, with data[i,j] giving
    a connection strength between i and j. The output graph has an
    edge i-j if data[i,j] > threshold.
    """
    N = data.shape[0]
    with open(output_filename, "w") as out_f:
        for i in range(N):
            for j in range(i):
                if data[i,j] > threshold:
                    out_f.write("%d -- %d" % (i + 1, j + 1) + "\n")

def generate_and_write_statistics(output_prefix, P, K, Q, V, A, u, k, a):
    (N_Q, N_V, N_A) = P.shape
    N_s = u.shape[0]
    e = keys_to_exams(K, k, u)

    n_s_e = np.zeros(N_e, dtype=int)
    for ei in range(N_e):
        for si in range(N_s):
            if K[ei] == k[si]:
                n_s_e[ei] += 1
    write_csv(output_prefix + "_n_s_e.csv", ["e", "n_s(e)"], n_s_e)

    n_s_QV = np.zeros((N_Q, N_V), dtype=int)
    for si in range(N_s):
        for qi in range(N_Q):
            n_s_QV[Q[e[si],qi], V[e[si],qi]] += 1
    write_csv(output_prefix + "_n_s_QV.csv", ["Q", "n_s(Q,V=%d)"], n_s_QV)

    n_a_QVA = np.zeros((N_Q, N_V, N_A), dtype=int)
    for si in range(N_s):
        for qi in range(N_Q):
            Ai = chr2ind(A[e[si],qi,chr2ind(a[si,qi])])
            if Ai >= 0:
                n_a_QVA[Q[e[si],qi], V[e[si],qi], Ai] += 1
    write_csv(output_prefix + "_n_a_QVA.csv", ["Q", "V", "n_a(Q,V,A=%s)"], n_a_QVA,
              index_formats=['i', 'i', 'c'])

    n_a_QV = n_a_QVA.sum(axis=2)
    write_csv(output_prefix + "_n_a_QV.csv", ["Q", "n_a(Q,V=%d)"], n_a_QV)

    n_a_Q = n_a_QV.sum(axis=1)
    write_csv(output_prefix + "_n_a_Q.csv", ["Q", "n_a(Q)"], n_a_Q)

    (P_seq, P_se, P_sq, P_s, P_sQ) = generate_grades(P, K, Q, V, A, u, k, a)

    P_QV = np.zeros((N_Q, N_V))
    for si in range(N_s):
        for qi in range(N_Q):
            P_QV[Q[e[si],qi], V[e[si],qi]] += P_sq[si,qi]
    write_csv(output_prefix + "_P_QV.csv", ["Q", "P(Q,V=%d)"], P_QV)

    P_Q = P_QV.sum(axis=1)
    write_csv(output_prefix + "_P_Q.csv", ["Q", "P(Q)"], P_Q)

    Pbar_QV = P_QV / np.where(n_s_QV > 0, n_s_QV, 1)
    write_csv(output_prefix + "_Pbar_QV.csv", ["Q", "Pbar(Q,V=%d)"], Pbar_QV)

    Pbar_Q = P_Q / N_s
    write_csv(output_prefix + "_Pbar_Q.csv", ["Q", "Pbar(Q)"], Pbar_Q)

    R_QV = np.zeros((N_Q, N_V))
    for Qi in range(N_Q):
        R_QV[Qi,:] = Pbar_QV[Qi,:] / Pbar_Q[Qi]
    write_csv(output_prefix + "_R_QV.csv", ["Q", "R(Q,V=%d)"], R_QV)

    R_QV_threshold_high = 1.2
    R_QV_threshold_low = 0.8
    for Qi in range(N_Q):
        for Vi in range(N_V):
            if R_QV[Qi,Vi] > R_QV_threshold_high:
                print("WARNING: R_QV(Q=%d,V=%d) = %f is unusually high"
                      % (Qi, Vi, R_QV[Qi,Vi]))
            if R_QV[Qi,Vi] < R_QV_threshold_low:
                print("WARNING: R_QV(Q=%d,V=%d) = %f is unusually low"
                      % (Qi, Vi, R_QV[Qi,Vi]))

    r_s_QQ = np.corrcoef(P_sQ.transpose())
    write_csv(output_prefix + "_r_s_QQ.csv", ["Q1", "r_s(Q1,Q2=%d)"], r_s_QQ)
    write_halfviz(output_prefix + "_r_s_QQ.halfviz", r_s_QQ, 0.2)

    r_Q_ss = np.corrcoef(P_sQ)
    write_csv(output_prefix + "_r_Q_ss.csv", ["s1", "r_Q(s1,s2=%d)"], r_Q_ss)
    write_halfviz(output_prefix + "_r_Q_ss.halfviz", r_Q_ss, 0.99)

    n_ai_ss = np.zeros((N_s, N_s), dtype=int)
    for si in range(N_s):
        for sj in range(N_s):
            for qi in range(N_Q):
                if P_sq[si,qi] == 0 and P_sq[sj,qi] == 0:
                    n_ai_ss[si,sj] += 1
    write_csv(output_prefix + "_n_ai_ss.csv", ["s1", "n_ai(s1,s2=%d)"], n_ai_ss)

    r_ai_ss = np.zeros((N_s, N_s), dtype=float)
    for si in range(N_s):
        for sj in range(N_s):
            for qi in range(N_Q):
                if P_sq[si,qi] == 0 and P_sq[sj,qi] == 0 and a[si,qi] == a[sj,qi]:
                    r_ai_ss[si,sj] += 1
    r_ai_ss /= n_ai_ss
    write_csv(output_prefix + "_r_ai_ss.csv", ["s1", "r_ai(s1,s2=%d)"], r_ai_ss)
    
    r_ai_ss_threshold = 2.0 / N_A
    n_ai_ss_threshold = 2
    for si in range(N_s):
        for sj in range(si):
            if e[si] == e[sj] and r_ai_ss[si,sj] > r_ai_ss_threshold and n_ai_ss[si,sj] > n_ai_ss_threshold:
                print("WARNING: s1 = %d, s2 = %d, r_ai_ss = %f, n_ai_ss = %d"
                      % (si, sj, r_ai_ss[si,sj], n_ai_ss[si,sj]))

######################################################################
######################################################################

if __name__ == "__main__":
    main()
