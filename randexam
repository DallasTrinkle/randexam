#!/usr/bin/env python

VERSION = "1.0.0"

######################################################################
######################################################################
# Configuration

FILENAME_PREFIX = ""

N_e = 5 # number of randomized exams
N_A = 5 # maximum number of answers per question
LAST_SCANTRON_QUESTION_NUMBER = 96

RANDOM_SEED = 7 # determines the random output

######################################################################
######################################################################
# Filenames

# input filenames
LIBRARY_FILENAME = FILENAME_PREFIX + "library.tex"
SCANTRON_FILENAME = FILENAME_PREFIX + "scantron.dat"

# output filenames
EXAMS_FILENAME = FILENAME_PREFIX + "exams.tex"
SOLUTIONS_FILENAME = FILENAME_PREFIX + "solutions.csv"
SPECS_FILENAME = FILENAME_PREFIX + "specs.csv"
POINTS_FILENAME = FILENAME_PREFIX + "points.csv"
ANSWERS_FILENAME = FILENAME_PREFIX + "answers.csv"
GRADES_FILENAME = FILENAME_PREFIX + "grades.csv"
STATS_PREFIX = FILENAME_PREFIX + "stats"

# logging filenames
LOG_PROC_LIB_FILENAME = FILENAME_PREFIX + "proc_lib.log"
LOG_PROC_SCAN_FILENAME = FILENAME_PREFIX + "proc_scan.log"
LOG_PROC_ANS_FILENAME = FILENAME_PREFIX + "proc_ans.log"

######################################################################
######################################################################

import re, random, sys, itertools, string, csv, os
import numpy as np

def main():
    if len(sys.argv) != 2:
        print("randexam version %s" % VERSION)
        print("")
        print("usage: randexam <command>")
        print("")
        print("<command> is:")
        print("   proc-lib     process the library and generate exams")
        print("   proc-scan    process and unscramble the scantron file")
        print("   proc-ans     process the answer file to produce grades")
        sys.exit(0)

    if sys.argv[1] == "proc-lib":
        protected_filenames = [f for f in [POINTS_FILENAME, SPECS_FILENAME, EXAMS_FILENAME, SOLUTIONS_FILENAME]
                               if os.path.exists(f)]
        if len(protected_filenames) > 0:
            print("ERROR: output files already exist, will not overwrite: %s"
                  % ", ".join(protected_filenames))
            sys.exit(1)
        init_logging(LOG_PROC_LIB_FILENAME)
        log_and_print("randexam version %s" % VERSION)
        random.seed(RANDOM_SEED)
        library = read_library(LIBRARY_FILENAME)
        check_library(library)
        (P, C) = extract_points(library, N_A)
        write_points(POINTS_FILENAME, P)
        (K, Q, V, A) = generate_specs(library, N_e, N_A)
        check_key_distances(K)
        write_specs(SPECS_FILENAME, K, Q, V, A)
        write_exams(EXAMS_FILENAME, library, K, Q, V, A)
        write_solutions(SOLUTIONS_FILENAME, library, K, Q, V, C)
    elif sys.argv[1] == "proc-scan":
        init_logging(LOG_PROC_SCAN_FILENAME)
        log_and_print("randexam version %s" % VERSION)
        (K, Q, V, A) = read_specs(SPECS_FILENAME)
        N_Q = Q.shape[1]
        (u, k, a) = read_scantrons(SCANTRON_FILENAME, N_e, N_Q, N_A)
        write_answers(ANSWERS_FILENAME, u, k, a)
    elif sys.argv[1] == "proc-ans":
        init_logging(LOG_PROC_ANS_FILENAME)
        log_and_print("randexam version %s" % VERSION)
        (K, Q, V, A) = read_specs(SPECS_FILENAME)
        (u, k, a) = read_answers(ANSWERS_FILENAME)
        P = read_points(POINTS_FILENAME)
        (P_seq, P_se, P_sq, P_s, P_sQ) = generate_grades(P, K, Q, V, A, u, k, a, warnings=True)
        write_grades(GRADES_FILENAME, u, P_s)
        generate_and_write_statistics(STATS_PREFIX, P, K, Q, V, A, u, k, a)
    else:
        print("ERROR: unrecognized command: %s" % sys.argv[1])
        print("valid commands are \"proc-lib\", \"proc-scan\", or \"proc-ans\"")
        sys.exit(1)

######################################################################
######################################################################

log_file = None

def init_logging(output_filename):
    global log_file
    try:
        print("Logging information to file: %s" % output_filename)
        if log_file != None:
            raise Exception("logging already initialized")
        log_file = open(output_filename, "w")
    except Exception as e:
        print("ERROR: failed to initialize logging: %s" % e)
        sys.exit(1)

def log(msg):
    global log_file
    try:
        if log_file == None:
            raise Exception("logging not initialized")
        log_file.write(msg + "\n")
    except Exception as e:
        print("ERROR: logging failed for message '%s': %s" % (msg, e))
        sys.exit(1)

def log_and_print(msg):
    log(msg)
    print(msg)

def die(msg):
    log_and_print(msg)
    sys.exit(1)

def log_array(arr, arr_name, dim_names):
    if len(arr.shape) != len(dim_names):
        die("log_array length mismatch for %s" % arr_name)
    log("%s array: (%s)"
        % (arr_name, ", ".join(["%s = %d" % (dim_names[i], arr.shape[i])
                                for i in range(len(arr.shape))])))
    log(np.array_str(arr))

######################################################################
######################################################################

class Library:
    def __init__(self):
        self.coverpage = ""
        self.zones = []

class Zone:
    def __init__(self):
        self.body = ""
        self.questions = []

class Question:
    def __init__(self):
        self.variants = []
        self.line_number = None
        self.points = 0
        self.scantron_uses = 0
        self.scantron_answers = 0
        self.scantron_points = 0

class Variant:
    def __init__(self):
        self.body = ""
        self.answers = []
        self.line_number = None
        self.scantron_uses = 0
        self.scantron_answers = 0
        self.scantron_points = 0

class Answer:
    def __init__(self):
        self.body = ""
        self.correct = False
        self.line_number = None
        self.points = 0
        self.scantron_answers = 0

class LibraryRegexp:
    def __init__(self, name, regexp, no_tail=False):
        self.name = name
        self.regexp = regexp
        self.no_tail = no_tail

class ReadState:
    def __init__(self):
        self.name = "preamble"
        self.zone = Zone()
        self.question = Question()
        self.variant = Variant()
        self.answer = Answer()

######################################################################
######################################################################

def ind2chr(index):
    """c = ind2chr(i)

    Convert the index i to a character c, so that 0 -> 'A', 1 -> 'B',
    etc. Invalid indexes convert to the character '*'.
    """
    index = int(index)
    if index < 0 or index >= len(string.ascii_uppercase):
        return "*"
    return string.ascii_uppercase[index]

def chr2ind(char):
    """i = ind2chr(c)

    Convert the character c to an index i, so that 'A' -> 0, 'B' -> 1,
    etc. Uppercase and lowercase are both converted. Invalid
    characters convert to -1.
    """
    if char in string.ascii_uppercase:
        return string.ascii_uppercase.index(char)
    if char in string.ascii_lowercase:
        return string.ascii_lowercase.index(char)
    return -1

######################################################################
######################################################################

def read_library(input_filename):
    log_and_print("Reading library file: %s" % input_filename)
    try:
        input_file = open(input_filename, "r")
    except Exception as e:
        die("ERROR: Unable to open library file for reading: %s: %s" % (input_filename, e))
    library_regexps = [
        LibraryRegexp(name="begin_document", regexp=r"^\s*\\begin\{document\}(?P<tail>.*)$", no_tail=True),
        LibraryRegexp(name="zone", regexp=r"^\s*\\zone(?P<tail>.*)$"),
        LibraryRegexp(name="question", regexp=r"^\s*\\question\{(?P<points>[0-9.]+)\}(?P<tail>.*)$", no_tail=True),
        LibraryRegexp(name="variant", regexp=r"^\s*\\variant(?P<tail>.*)$"),
        LibraryRegexp(name="begin_answers", regexp=r"^\s*\\begin\{answers\}(?P<tail>.*)$", no_tail=True),
        LibraryRegexp(name="answer", regexp=r"^\s*\\answer(?P<tail>.*)$"),
        LibraryRegexp(name="correct_answer", regexp=r"^\s*\\correctanswer(?P<tail>.*)$"),
        LibraryRegexp(name="end_answers", regexp=r"^\s*\\end\{answers\}(?P<tail>.*)$", no_tail=True),
        LibraryRegexp(name="end_document", regexp=r"^\s*\\end\{document\}(?P<tail>.*)$", no_tail=True),
        LibraryRegexp(name="text", regexp=r"^.*\S.*$"),
        LibraryRegexp(name="blank", regexp=r"^\s*$"),
        ]
    library = Library()
    state = ReadState()
    for (i_line, line) in enumerate(input_file):
        def file_log(msg):
            log("%s:%d: %s" % (input_filename, i_line + 1, msg))
        def file_die(msg):
            die("%s:%d: ERROR: %s" % (input_filename, i_line + 1, msg))
        line = line.strip()
        file_log("read line: \"%s\"" % line)
            
        match_comment = re.search(r"(?<!\\)%", line)
        if match_comment:
            line = line[:match_comment.start()]
            file_log("stripped comments: \"%s\"" % line)
        match_name = None
        match = None
        for library_regexp in library_regexps:
            match = re.match(library_regexp.regexp, line)
            if match:
                match_name = library_regexp.name
                if library_regexp.no_tail:
                    extra_text = match.group("tail").strip()
                    if len(extra_text) > 0:
                        file_die("invalid extra text following '%s': %s" % (match_name, extra_text))
                break
        else:
            file_die("no matches found for line")
        file_log("found match '%s'" % match_name)

        def transition(new_state_name):
            file_log(r"state transition: '%s' -> '%s'" % (state.name, new_state_name))
            state.name = new_state_name
        def bad_transition():
            file_die("'%s' not allowed in state '%s'" % (match_name, state.name))
        def new_zone():
            file_log("starting new zone")
            state.zone = Zone()
            library.zones.append(state.zone)
            state.zone.line_number = i_line + 1
            state.zone.body = match.group("tail").strip()
        def new_question():
            file_log("starting new question")
            state.question = Question()
            state.zone.questions.append(state.question)
            state.question.line_number = i_line + 1
            try:
                state.question.points = float(match.group("points"))
            except Exception as e:
                file_die("unable to determine points for question")
        def new_variant():
            file_log("starting new variant")
            state.variant = Variant()
            state.question.variants.append(state.variant)
            state.variant.line_number = i_line + 1
            state.variant.body = match.group("tail").strip()
        def new_answer(correct):
            file_log("starting new answer")
            state.answer = Answer()
            state.variant.answers.append(state.answer)
            state.answer.line_number = i_line + 1
            state.answer.body = match.group("tail").strip()
            state.answer.correct = correct
        def append_to_coverpage():
            file_log("appending line to coverpage")
            if len(library.coverpage) > 0:
                library.coverpage += "\n"
            library.coverpage += line
        def append_to_zone_body():
            file_log("appending line to zone body")
            if len(state.zone.body) > 0:
                state.zone.body += "\n"
            state.zone.body += line
        def append_to_variant_body():
            file_log("appending line to variant body")
            if len(state.variant.body) > 0:
                state.variant.body += "\n"
            state.variant.body += line
        def append_to_answer_body():
            file_log("appending line to answer body")
            if len(state.answer.body) > 0:
                state.answer.body += "\n"
            state.answer.body += line

        if state.name == "preamble":
            if match_name == "begin_document":   transition("coverpage")
            elif match_name == "text":           file_log("skipping text line")
            elif match_name == "blank":          file_log("skipping blank line")
            else: bad_transition()
        elif state.name == "coverpage":
            if match_name == "text":             append_to_coverpage()
            elif match_name == "blank":          append_to_coverpage()
            elif match_name == "zone":           transition("zone"); new_zone()
            else: bad_transition()
        elif state.name == "zone":
            if match_name == "text":             append_to_zone_body()
            elif match_name == "blank":          append_to_zone_body()
            elif match_name == "question":       transition("question"); new_question()
            elif match_name == "zone":           transition("zone"); new_zone()
            elif match_name == "end_document":   file_log("stopping file reading"); break
            else: bad_transition()
        elif state.name == "question":
            if match_name == "variant":          transition("variant"); new_variant()
            elif match_name == "question":       transition("question"); new_question()
            elif match_name == "zone":           transition("zone"); new_zone()
            elif match_name == "end_document":   file_log("stopping file reading"); break
            elif match_name == "blank":          file_log("skipping blank line")
            else: bad_transition()
        elif state.name == "variant":
            if match_name == "text":             append_to_variant_body()
            elif match_name == "blank":          append_to_variant_body()
            elif match_name == "begin_answers":  transition("answers")
            else: bad_transition()
        elif state.name == "answers":
            if match_name == "correct_answer":   transition("answer"); new_answer(correct=True)
            elif match_name == "answer":         transition("answer"); new_answer(correct=False)
            elif match_name == "blank":          file_log("skipping blank line")
            else: bad_transition()
        elif state.name == "answer":
            if match_name == "text":             append_to_answer_body()
            elif match_name == "blank":          append_to_answer_body()
            elif match_name == "correct_answer": transition("answer"); new_answer(correct=True)
            elif match_name == "answer":         transition("answer"); new_answer(correct=False)
            elif match_name == "end_answers":    transition("question")
            else: bad_transition()
        else:
            file_die("unknown state '%s'", state.name)

    input_file.close()
    log("Successfully completed library reading")
    return library

def check_library(library):
    log_and_print("Checking library data")
    errors = []
    if len(library.zones) == 0:
        errors.append("ERROR: no zones")
    log_and_print("For each question variant listed below, V#-S#-# shows:")
    log_and_print("  variant number - number of answers - correct answer letter")
    total_points = 0
    Qi = 0
    for (i_zone, zone) in enumerate(library.zones):
        log_and_print("Zone %d: %d questions" % (i_zone + 1, len(zone.questions)))
        for question in zone.questions:
            variant_infos = []
            if len(question.variants) == 0:
                errors.append("question %d (line %d): no variants"
                              % (Qi + 1, question.line_number))
            for (i_variant, variant) in enumerate(question.variants):
                if len(variant.body) == 0:
                    errors.append("question %d, variant %d (line %d): no body text"
                                  % (Qi + 1, i_variant + 1, variant.line_number))
                if len(variant.answers) < 2:
                    errors.append("question %d, variant %d (line %d): less than 2 answers"
                                  % (Qi + 1, i_variant + 1, variant.line_number))
                correct_answer_indexes = []
                for (i_answer, answer) in enumerate(variant.answers):
                    if len(answer.body) == 0:
                        errors.append("question %d, variant %d, answer %d (line %d): no body text"
                                      % (Qi + 1, i_variant + 1, i_answer + 1, answer.line_number))
                    if answer.correct:
                        correct_answer_indexes.append(i_answer)
                if len(correct_answer_indexes) == 0:
                    errors.append("question %d, variant %d (line %d): no correct answer"
                                  % (Qi + 1, i_variant + 1, variant.line_number))
                if len(correct_answer_indexes) > 1:
                    errors.append("question %d, variant %d (line %d): more than one correct answer"
                                  % (Qi + 1, i_variant + 1, variant.line_number))
                variant_infos.append("V%d-S%d-%s"
                                     % (i_variant + 1, len(variant.answers),
                                        "".join([ind2chr(i) for i in correct_answer_indexes])))
            log_and_print("    Question %d (%g points): %s" % (Qi + 1, question.points, ", ".join(variant_infos)))
            total_points += question.points
            Qi += 1
    if Qi == 0:
        errors.append("no questions in library")
    log_and_print("Total points: %g" % total_points)
    if len(errors) > 0:
        for error in errors:
            log_and_print("ERROR: %s" % error)
        die("Errors found during library checking")
    log("Successfully completed library checking")

######################################################################
######################################################################

def extract_points(library, N_A):
    """(P, C) = extract_points(library, N_A)

    Extract the correct solutions and points from the library.
    Returns:

    P[Q,V,A] = points for answer A of variant V of library question Q
    C[Q,V] = the correct answer for variant V of library question Q
    """
    log_and_print("Extracting points from library data")
    flat_questions = list(itertools.chain.from_iterable([zone.questions for zone in library.zones]))
    N_Q = len(flat_questions)
    N_V = max([len(q.variants) for q in flat_questions])

    P = np.zeros((N_Q, N_V, N_A), dtype=float)
    C = np.zeros((N_Q, N_V), dtype=str)

    for Qi in range(N_Q):
        for Vi in range(N_V):
            for Ai in range(N_A):
                if Vi < len(flat_questions[Qi].variants):
                    if Ai < len(flat_questions[Qi].variants[Vi].answers):
                        if flat_questions[Qi].variants[Vi].answers[Ai].correct:
                            C[Qi,Vi] = ind2chr(Ai)
                            P[Qi,Vi,Ai] = flat_questions[Qi].points
    log_array(P, "P", ["N_Q", "N_V", "N_A"])
    log_array(C, "C", ["N_Q", "N_V"])
    log("Successfully completed extracting points from library data")
    return (P, C)

def write_points(output_filename, P):
    log_and_print("Writing points file: %s" % output_filename)
    (N_Q, N_V, N_A) = P.shape
    with open(output_filename, 'w') as out_f:
        writer = csv.writer(out_f)
        writer.writerow(["Q", "V", "A", "P(Q,V,A)"])
        for Qi in range(N_Q):
            for Vi in range(N_V):
                for Ai in range(N_A):
                    writer.writerow([Qi + 1, Vi + 1, ind2chr(Ai), P[Qi,Vi,Ai]])
    log("Successfully completed writing points file")

def read_points(input_filename):
    log_and_print("Reading points data from file: %s" % input_filename)
    Q_data = []
    V_data = []
    A_data = []
    P_data = []
    with open(input_filename, "r") as in_f:
        reader = csv.reader(in_f)
        for (i_row, row) in enumerate(reader):
            if i_row == 0:
                continue # skip header
            if len(row) != 4:
                die("%s:%d: ERROR: expected 4 entries but got %d"
                    % (input_filename, i_row + 1, len(row)))
            try:
                Q_data.append(int(row[0]) - 1)
                V_data.append(int(row[1]) - 1)
                A_data.append(chr2ind(row[2]))
                P_data.append(float(row[3]))
            except Exception as e:
                die("%s:%s: ERROR: %s" % (input_filename, i_row + 1, e))
    N_Q = max(Q_data) + 1
    N_V = max(V_data) + 1
    N_A = max(A_data) + 1
    P = np.array(P_data, dtype=float).reshape((N_Q, N_V, N_A))
    log_array(P, "P", ["N_Q", "N_V", "N_A"])
    log("Successfully completed reading points data")
    return P

######################################################################
######################################################################

def generate_specs(library, N_e, N_A):
    """(K, Q, V, A) = generate_specs(library, N_e)

    K[e] = exam key
    Q[e,q] = library question number for exam e, question q
    V[e,q] = library variant number for exam e, question q
    A[e,q,a] = library answer number for exam e, question q, answer a
    """
    log_and_print("Generating %d random exam specifications" % N_e)
    flat_questions = list(itertools.chain.from_iterable([zone.questions for zone in library.zones]))
    N_Q = len(flat_questions)
    N_V = max([len(q.variants) for q in flat_questions])

    K = np.empty(N_e, dtype=object)
    Q = np.zeros((N_e, N_Q), dtype=int)
    V = np.zeros((N_e, N_Q), dtype=int)
    A = np.zeros((N_e, N_Q, N_A), dtype=str)

    # generate N_e random exams
    for ei in range(N_e):
        K[ei] = generate_key(ei, N_e, N_A)

        # randomize question order within each zone
        q_list = []
        Qi = 0
        for (i_zone, zone) in enumerate(library.zones):
            q_zone = list(range(Qi, (Qi + len(zone.questions))))
            random.shuffle(q_zone)
            q_list.extend(q_zone)
            Qi += len(zone.questions)
        Q[ei,:] = np.array(q_list)

        # choose random variant for each question and randomize answer order
        for qi in range(N_Q):
            question = flat_questions[Q[ei,qi]]
            V[ei,qi] = random.randrange(len(question.variants))
            a_list = list(range(len(question.variants[V[ei,qi]].answers)))
            random.shuffle(a_list)
            A[ei,qi,:] = np.array([ind2chr(i) for i in a_list])

    log_array(K, "K", ["N_e"])
    log_array(Q, "Q", ["N_e", "N_Q"])
    log_array(V, "V", ["N_e", "N_Q"])
    log_array(A, "A", ["N_e", "N_Q", "N_A"])
    log("Successfully completed generating random exam specifications")
    return (K, Q, V, A)

def write_specs(output_filename, K, Q, V, A):
    log_and_print("Writing exam specs to file: %s" % output_filename)
    (N_e, N_Q) = Q.shape
    with open(output_filename, 'w') as out_f:
        writer = csv.writer(out_f)
        row = ["e", "K(e)"]
        for qi in range(N_Q):
            row.extend(["Q(e,q=%d)" % (qi + 1), "V(e,q=%d)" % (qi + 1), "A(e,q=%d,:)" % (qi + 1)])
        writer.writerow(row)
        for ei in range(N_e):
            row = [ei + 1, K[ei]]
            for qi in range(N_Q):
                row.extend([Q[ei,qi] + 1, V[ei,qi] + 1, "".join(A[ei,qi,:])])
            writer.writerow(row)
    log("Successfully completed writing exam specs to file")

def read_specs(input_filename):
    log_and_print("Reading exam specifications from file: %s" % input_filename)
    K_data = []
    Q_data = []
    V_data = []
    A_data = []
    with open(input_filename, "r") as in_f:
        reader = csv.reader(in_f)
        for (i_row, row) in enumerate(reader):
            if i_row == 0:
                continue # skip header
            if (len(row) - 2) % 3 != 0:
                die("%s:%d: ERROR: expected 3N+2 items in row, got %d"
                    % (input_filename, i_row + 1, len(row)))
            K_data.append(row[1])
            data = np.array(row[2:], dtype=object).reshape((-1, 3))
            Q_data.append([int(d) - 1 for d in data[:,0]])
            V_data.append([int(d) - 1 for d in data[:,1]])
            A_data.append([list(d) for d in data[:,2]])
    K = np.array(K_data, dtype=object)
    Q = np.array(Q_data, dtype=int)
    V = np.array(V_data, dtype=int)
    A = np.array(A_data, dtype=str)
    log_array(K, "K", ["N_e"])
    log_array(Q, "Q", ["N_e", "N_Q"])
    log_array(V, "V", ["N_e", "N_Q"])
    log_array(A, "A", ["N_e", "N_Q", "N_A"])
    log("Successfully completed reading exam specifications from file")
    return (K, Q, V, A)

######################################################################
######################################################################

def generate_key(e, N_e, N_A):
    """K = generate_key(e, N_e, N_A)
    
    Generates a key for exam number e of N_e total exams.

    The key is a base-N_A encoding of the exam number with 2 or 3
    checksum digits appended.

    check1 is just a parity check
    check2 is a Fletcher checksum
    check3 is a modified Fletcher checksum
    A minimum Hamming distance of 3 between keys is guaranteed by:
      check1 and check2 for n_digits <= (N_A - 1)
      all three checksums for n_digits <= (N_A - 1)^2
    """
    for n_digits in range(10):
        if N_A**n_digits >= N_e:
            break
    else:
        raise Exception("too many exam variants to determine n_digits")
    key_array = []
    check1 = 3 % N_A # shift to avoid "AA" having check "A"
    check2 = 2 % N_A
    check3 = 4 % N_A
    for i in range(n_digits):
        d = (e // N_A**i) % N_A
        key_array.append(d)
        check1 = (check1 + d) % N_A
        check2 = (check2 + (i % (N_A - 1) + 1) * d) % N_A
        check3 = (check3 + (i // (N_A - 1) % (N_A - 1) + 1) * d) % N_A
    key_array.append(check1)
    key_array.append(check2)
    if (n_digits > N_A - 1):
        key_array.append(check3)
    key = "".join([["A", "B", "C", "D", "E"][i] for i in key_array]);
    return key

def hamming_distance(Ki, Kj):
    """Computes the Hamming distance between keys Ki and Kj.

    >>> hamming_distance("ABC", "AEC")
    1
    """
    if len(Ki) != len(Kj):
        raise Exception("cannot compute Hamming distance for keys "
                        + "of different lengths: %s, %s" % (Ki, Kj))
    different_indexes = [i for i in range(len(Ki)) if Ki[i] != Kj[i]]
    return len(different_indexes)

def check_key_distances(K):
    """Checks that the keys are all distinct and prints the
    minimum Hamming distance between keys.
    """
    log_and_print("Checking Hamming distances between exam keys")
    N_e = K.shape[0]
    if N_e < 1:
        return
    min_d = len(K[0])
    for ei in range(N_e):
        for ej in range(ei):
            if K[ei] == K[ej]:
                raise Exception("duplicate key %s found" % K[ei])
            min_d = min(min_d, hamming_distance(K[ei], K[ej]))
    log_and_print("Minimum Hamming distance between keys: %d" % min_d)
    if min_d < 3:
        die("ERROR: Minimum Hamming distance %d is less than 3" % min_d)
    log("Successfully completed checking minimum Hamming distances")

######################################################################
######################################################################

def write_exams(output_filename, library, K, Q, V, A):
    log_and_print("Writing randomized exams to file: %s" % output_filename)
    (N_e, N_Q, N_A) = A.shape

    flat_questions = list(itertools.chain.from_iterable([zone.questions for zone in library.zones]))
    with open(output_filename, "w") as out_f:
        out_f.write(r"\documentclass[twoside]{article}" + "\n")
        out_f.write(r"\usepackage{amsmath,amssymb}" + "\n")
        out_f.write(r"\usepackage[margin=3cm]{geometry}" + "\n")
        out_f.write(r"\usepackage{graphicx}" + "\n")
        out_f.write(r"\begin{document}" + "\n")

        for ei in range(N_e):
            out_f.write(("%" * 70 + "\n") * 4)
            out_f.write(r"%% Exam number %d" % (ei + 1) + "\n\n")
            out_f.write(r"\cleardoublepage" + "\n")
            out_f.write(r"\setcounter{page}{1}" + "\n\n")
            out_f.write(library.coverpage + "\n")
            out_f.write(r"\begin{enumerate}" + "\n")
            for (i_key_digit, key_digit) in enumerate(K[ei]):
                key_question = LAST_SCANTRON_QUESTION_NUMBER - len(K[ei]) + i_key_digit + 1
                out_f.write(r"\item[%d.] %s" % (key_question, key_digit) + "\n")
            out_f.write(r"\end{enumerate}" + "\n\n")
            out_f.write(r"\newpage" + "\n\n")

            qi = 0
            for (i_zone, zone) in enumerate(library.zones):
                out_f.write("%% Zone %d\n\n" % (i_zone + 1))
                out_f.write(zone.body + "\n\n")
                for i_zone_question in range(len(zone.questions)):
                    out_f.write(r"\noindent" + "\n")
                    out_f.write(r"\begin{minipage}{\textwidth}" + "\n")
                    points = flat_questions[Q[ei,qi]].points
                    out_f.write(r"%d. (%g %s)" % (qi + 1, points,
                                                  "point" if points == 1 else "points")
                                + "\n")
                    variant = flat_questions[Q[ei,qi]].variants[V[ei,qi]]
                    out_f.write(variant.body + "\n")
                    out_f.write(r"\begin{enumerate}" + "\n")
                    for ai in range(N_A):
                        out_f.write(r"\item[(%s)]" % ind2chr(ai) + "\n")
                        out_f.write(variant.answers[chr2ind(A[ei,qi,ai])].body + "\n")
                    out_f.write(r"\end{enumerate}" + "\n")
                    out_f.write(r"\vspace*{10em}" + "\n")
                    out_f.write(r"\end{minipage}" + "\n")
                    out_f.write(r"\filbreak\vfil\penalty-200\vfilneg" + "\n\n")

                    qi += 1

        out_f.write(r"\end{document}" + "\n")
    log("Successfully completed writing randomized exams")

######################################################################
######################################################################

def write_solutions(output_filename, library, K, Q, V, C):
    log_and_print("Writing solutions to file: %s" % output_filename)
    (N_e, N_Q) = Q.shape

    with open(output_filename, "w") as out_f:
        writer = csv.writer(out_f)
        writer.writerow(["e", "K(e)"] + ["C(e,q=%d)" % (q + 1) for q in range(N_Q)])
        for e in range(N_e):
            writer.writerow([e + 1, K[e]] + [C[Q[e,q], V[e,q]] for q in range(N_Q)])
    log("Successfully completed writing solutions to file")

######################################################################
######################################################################

def read_scantrons(input_filename, N_e, N_Q, N_A):
    log_and_print("Reading Scantron file: %s" % input_filename)
    key_length = len(generate_key(0, N_e, N_A))
    u_data = []
    k_data = []
    a_data = []
    key_length = len(generate_key(0, N_e, N_A))
    with open(input_filename, "r") as in_f:
        for (i_line, line) in enumerate(in_f):
            def check_match(s, pattern, offset, field, min_length, strip):
                if strip:
                    s = s.strip()
                cleaned_s = re.sub(pattern, " ", s)
                if strip:
                    cleaned_s = cleaned_s.strip()
                if len(s) == 0 and min_length > 0:
                    log_and_print("%s:%s: WARNING: field '%s' at character %d is empty"
                                  % (input_filename, i_line + 1, field, offset + 1))
                    return cleaned_s
                if len(s) < min_length:
                    log_and_print("%s:%s: WARNING: field '%s' at character %d has length %d but should be at least %d: %s"
                                  % (input_filename, i_line + 1, field, offset + 1, len(s), min_length, s))
                    return cleaned_s
                bad_chars = False
                for match in re.finditer(pattern, s):
                    bad_chars = True
                    i = match.start()
                    log_and_print("%s:%s: WARNING: invalid character '%s' at character %d at position %d in field '%s': %s"
                                  % (input_filename, i_line + 1, s[i], i + offset + 1, i + 1, field, s))
                if bad_chars:
                    return cleaned_s
                return s

            if len(line) == 1 and ord(line[0]) == 26:
                # last line has a single char
                continue

            key_end = 72 + LAST_SCANTRON_QUESTION_NUMBER
            key_start = key_end - key_length

            if len(line) < key_end:
                die("%s:%d: ERROR: line length %d less than expected %d" \
                        % (input_filename, i_line + 1, len(line), key_end))

            last_name = check_match(line[40:50], "[^A-Z ]", 40, "Last Name", 1, True)
            first_initial = check_match(line[50:51], "[^A-Z]", 50, "First Initial", 1, True)
            student_number = check_match(line[51:60], "[^0-9]", 51, "Student Number", 9, True)
            section = check_match(line[60:63], "[^0-9]", 60, "Section", 0, True)
            network_id = check_match(line[63:71], "[^A-Z0-9]", 63, "Network ID", 1, True)
            test_form = check_match(line[71:71], "[^A-Z]", 71, "Test Form", 0, True)
            answers = check_match(line[72:72 + N_Q], "[^0-9 ]", 72, "Answers", 0, False)
            key = check_match(line[key_start:key_end], "[^0-9]", key_start, "Key", key_length, False)

            answers = ["*" if c == " " else ind2chr(int(c) - 1)
                       for c in answers]
            key = "".join(["*" if c == " " else ind2chr(int(c) - 1)
                           for c in key])
            log("%s:%s: student %s/%s/%s/%s"
                % (input_filename, i_line + 1, last_name, first_initial, student_number, network_id))

            u_data.append([last_name, first_initial, student_number, network_id])
            k_data.append(key)
            a_data.append(list(answers))

    u = np.array(u_data, dtype=object)
    k = np.array(k_data, dtype=object)
    a = np.array(a_data, dtype=str)
    log_array(u, "u", ["N_s", "N_i"])
    log_array(k, "k", ["N_s"])
    log_array(a, "a", ["N_s", "N_Q"])
    log("Successfully completed reading Scantron file")
    return (u, k, a)

def write_answers(output_filename, u, k, a):
    log_and_print("Writing answers to file: %s" % output_filename)
    (N_s, N_Q) = a.shape
    with open(output_filename, 'w') as out_f:
        writer = csv.writer(out_f)
        writer.writerow(["s", "Name", "Initial", "Number", "NetID", "k(s)"]
                        + ["a(s,q=%d)" % (q + 1) for q in range(N_Q)])
        for si in range(N_s):
            writer.writerow([si + 1, u[si,0], u[si,1], u[si,2], u[si,3], k[si]]
                            + [a[si,qi] for qi in range(N_Q)])
    log("Successfully completed writing answers to file")

def read_answers(input_filename):
    log_and_print("Reading answers from file: %s" % input_filename)
    u_data = []
    k_data = []
    a_data = []
    with open(input_filename, "r") as in_f:
        reader = csv.reader(in_f)
        for (i_row, row) in enumerate(reader):
            if i_row == 0:
                continue # skip header
            if len(row) < 6:
                die("%s:%d: ERROR: expected at least 6 items in row, got %d"
                    (input_filename, i_row + 1, len(row)))
            u_data.append(row[1:5])
            k_data.append(row[5])
            a_data.append(row[6:])
    u = np.array(u_data, dtype=object)
    k = np.array(k_data, dtype=object)
    a = np.array(a_data, dtype=str)
    log_array(u, "u", ["N_s", "N_i"])
    log_array(k, "k", ["N_s"])
    log_array(a, "a", ["N_s", "N_Q"])
    log("Successfully completed reading answers from file")
    return (u, k, a)

######################################################################
######################################################################

def keys_to_exams(K, k, u, warnings=False):
    log_and_print("Matching keys to exams")
    N_s = k.shape[0]
    N_e = K.shape[0]
    e = np.zeros(N_s, dtype=int)
    for si in range(N_s):
        if k[si] in K:
            e[si] = np.argwhere(K == k[si])[0, 0]
        else:
            e[si] = -1
            if warnings:
                best_matches = []
                min_d = 10000
                for ei in range(N_e):
                    d = hamming_distance(K[ei], k[si])
                    if d < min_d:
                        min_d = d
                        best_matches = [K[ei]]
                    elif d == min_d:
                        best_matches.append(K[ei])
                if len(best_matches) == 1:
                    best_string = "best match is %s (Hamming distance %d)" % (best_matches[0], min_d)
                else:
                    best_string = "best matches are %s (all at Hamming distance %d)" \
                        % (",".join(best_matches), min_d)
                log_and_print("WARNING: key '%s' for student %s/%s/%s/%s not found: %s"
                                  % (k[si], u[si,0], u[si,1], u[si,2], u[si,3], best_string))
    log_array(e, "e", ["N_s"])
    log("Successfully completed matching keys to exams")
    return e

def generate_grades(P, K, Q, V, A, u, k, a, warnings=False):
    log_and_print("Generating grades")
    (N_Q, N_V, N_A) = P.shape
    N_s = u.shape[0]
    N_e = K.shape[0]

    e = keys_to_exams(K, k, u, warnings)

    P_seq = np.zeros((N_s, N_e, N_Q))
    for si in range(N_s):
        for ei in range(N_e):
            for qi in range(N_Q):
                ai = chr2ind(a[si,qi])
                Ai = chr2ind(A[ei,qi,ai])
                Qi = Q[ei,qi]
                Vi = V[ei,qi]
                if ai >= 0 and Ai >= 0 and Qi >= 0 and Vi >= 0:
                    P_seq[si,ei,qi] = P[Qi,Vi,Ai]
    P_se = P_seq.sum(axis=2)
    
    P_sq = np.zeros((N_s, N_Q))
    P_sQ = np.zeros((N_s, N_Q))
    P_s = np.zeros(N_s)
    for si in range(N_s):
        ei = e[si]
        if ei >= 0:
            P_s[si] = P_se[si,ei]
            for qi in range(N_Q):
                Qi = Q[ei,qi]
                if ei >= 0 and Qi >= 0:
                    P_sq[si,qi] = P_seq[si,ei,qi]
                    P_sQ[si,Qi] = P_seq[si,ei,qi]

    if warnings:
        for si in range(N_s):
            best_e = P_se[si,:].argmax()
            ei = e[si]
            if ei < 0:
                if P_se[si,best_e] > 0:
                    log_and_print(("WARNING: %s/%s/%s/%s: invalid key %s, "
                                   + "best match is %s with %g points (Hamming distance %d)")
                                  % (u[si,0], u[si,1], u[si,2], u[si,3], k[si], K[best_e],
                                     P_se[si,best_e], hamming_distance(k[si], K[best_e])))
                else:
                    log_and_print("WARNING: %s/%s/%s/%s: invalid key %s, no match gives any points"
                                  % (u[si,0], u[si,1], u[si,2], u[si,3], k[si]))
            else:
                if P_se[si,best_e] > P_se[si,ei]:
                    log_and_print(("WARNING: %s/%s/%s/%s got %g points with valid key %s, "
                                   + "but best match is %s with %g points (Hamming distance %d)")
                                  % (u[si,0], u[si,1], u[si,2], u[si,3], P_se[si,ei], K[ei], K[best_e],
                                     P_se[si,best_e], hamming_distance(K[ei], K[best_e])))

    log_array(P_seq, "P_seq", ["N_s", "N_e", "N_Q"])
    log_array(P_se, "P_se", ["N_s", "N_e"])
    log_array(P_sq, "P_sq", ["N_s", "N_Q"])
    log_array(P_s, "P_s", ["N_s"])
    log_array(P_sQ, "P_sQ", ["N_s", "N_Q"])
    log("Successfully completed generating grades")
    return (P_seq, P_se, P_sq, P_s, P_sQ)

def write_grades(output_filename, u, P_s):
    log_and_print("Writing grades to file: %s" % output_filename)
    N_s = u.shape[0]

    with open(output_filename, 'w') as out_f:
        writer = csv.writer(out_f)
        writer.writerow(["s", "Name", "Initial", "Number", "NetID", "P_s(s)"])
        for si in range(N_s):
            writer.writerow([si + 1, u[si,0], u[si,1], u[si,2], u[si,3], P_s[si]])
    log("Successfully completed writing grades to file")

def write_csv(output_filename, headers, data, index_formats=None):
    """Write the given array as a CSV file.

    For 1D data there should be two headers, index and value. For nD
    data there should be n headers, with the last header containing a
    %d conversion character.

    An nD array is written with the first n - 1 indexes as rows, and
    the last index as the columns. Breaking this rule, a 1D array is
    written as a column.
    """
    log_and_print("Writing statistics file: %s" % output_filename)
    if index_formats == None:
        index_formats = ["i"] * len(data.shape)
    def format_index(i, f):
        if f == "i":
            return i + 1
        elif f == "c":
            return ind2chr(i)
    with open(output_filename, "w") as out_f:
        writer = csv.writer(out_f)
        if len(data.shape) == 0:
            writer.writerow(header[0])
            writer.writerow(data[0])
        elif len(data.shape) == 1:
            assert(len(headers) == 2)
            writer.writerow(headers)
            for i in range(data.shape[0]):
                writer.writerow([format_index(i, index_formats[0]), data[i]])
        else:
            row = headers[:-1]
            for j in range(data.shape[-1]):
                row.append(headers[-1] % format_index(j, index_formats[-1]))
            writer.writerow(row)
            for index in np.ndindex(data.shape[:-1]):
                row = [format_index(index[i], index_formats[i])
                           for i in range(len(index))]
                for j in range(data.shape[-1]):
                    row.append(data[index + (j,)])
                writer.writerow(row)
    log("Successfully completed writing statistics file")

def write_halfviz(output_filename, data, threshold):
    """Write a graph from the given data in halfviz format.

    The data array must be square and symmetric, with data[i,j] giving
    a connection strength between i and j. The output graph has an
    edge i-j if data[i,j] > threshold.
    """
    log_and_print("Writing graph file: %s" % output_filename)
    N = data.shape[0]
    with open(output_filename, "w") as out_f:
        for i in range(N):
            for j in range(i):
                if data[i,j] > threshold:
                    out_f.write("%d -- %d" % (i + 1, j + 1) + "\n")
    log("Successfully completed writing graph file")

def tex_write_basic_stats(out_f, P_s, P):
    max_grade = P.max(axis=2).max(axis=1).sum()
    out_f.write(r"\begin{center}" + "\n")
    out_f.write(r"\begin{tabular}{|l|l|l|}" + "\n")
    out_f.write(r"\hline" + "\n")
    out_f.write(r"number of students & %d & \\" % len(P_s) + "\n")
    out_f.write(r"\hline" + "\n")
    out_f.write(r"minimum score & %g & %.1f\%% \\" % (P_s.min(), P_s.min() / max_grade * 100) + "\n")
    out_f.write(r"\hline" + "\n")
    out_f.write(r"maximum score & %g & %.1f\%% \\" % (P_s.max(), P_s.max() / max_grade * 100) + "\n")
    out_f.write(r"\hline" + "\n")
    out_f.write(r"mean score & %g & %.1f\%% \\" % (P_s.mean(), P_s.mean() / max_grade * 100) + "\n")
    out_f.write(r"\hline" + "\n")
    out_f.write(r"median score & %g & %.1f\%% \\" % (np.median(P_s), np.median(P_s) / max_grade * 100) + "\n")
    out_f.write(r"\hline" + "\n")
    out_f.write(r"std. dev. & %g & %.1f\%% \\" % (np.std(P_s), np.std(P_s) / max_grade * 100) + "\n")
    out_f.write(r"\hline" + "\n")
    out_f.write(r"\end{tabular}" + "\n")
    out_f.write(r"\end{center}" + "\n")

def tex_write_pdf(out_f, P_s, P):
    min_grade = 0
    max_grade = P.max(axis=2).max(axis=1).sum()
    n_bins = 20
    (hist, bin_edges) = np.histogram(P_s, bins=n_bins, range=(min_grade, max_grade))
    out_f.write(r"\begin{center}" + "\n")
    out_f.write(r"\begin{tikzpicture}" + "\n")
    out_f.write(r"\begin{axis}[" + "\n")
    out_f.write(r"xlabel={score}," + "\n")
    out_f.write(r"ylabel={number of students}," + "\n")
    out_f.write(r"ylabel style={overlay}," + "\n")
    out_f.write(r"yticklabel style={overlay}," + "\n")
    out_f.write(r"xmajorgrids=true," + "\n")
    out_f.write(r"ymajorgrids=true," + "\n")
    out_f.write(r"]" + "\n")
    out_f.write(r"\addplot+[ybar interval] plot coordinates {" + "\n")
    for i in range(len(hist)):
        out_f.write(r"(%g,%g)" % (bin_edges[i], hist[i]) + "\n")
    out_f.write(r"(%g,%g)" % (bin_edges[-1], hist[-1]) + "\n")
    out_f.write(r"};" + "\n")
    out_f.write(r"\end{axis}" + "\n")
    out_f.write(r"\end{tikzpicture}" + "\n")
    out_f.write(r"\end{center}" + "\n")

def tex_write_cdf(out_f, P_s, P):
    min_grade = 0
    max_grade = P.max(axis=2).max(axis=1).sum()
    sorted_P_s = P_s.copy()
    sorted_P_s.sort()
    out_f.write(r"\begin{center}" + "\n")
    out_f.write(r"\begin{tikzpicture}" + "\n")
    out_f.write(r"\begin{axis}[" + "\n")
    out_f.write(r"xlabel={score}," + "\n")
    out_f.write(r"ylabel={cumulative number of students}," + "\n")
    out_f.write(r"ylabel style={overlay}," + "\n")
    out_f.write(r"yticklabel style={overlay}," + "\n")
    out_f.write(r"xmajorgrids=true," + "\n")
    out_f.write(r"ymajorgrids=true," + "\n")
    out_f.write(r"]" + "\n")
    out_f.write(r"\addplot[const plot, draw=blue] coordinates {" + "\n")
    out_f.write(r"(%g,0)" % min_grade + "\n")
    for i in range(len(P_s)):
        out_f.write(r"(%g,%d)" % (sorted_P_s[i], i + 1) + "\n")
    out_f.write(r"(%g,%d)" % (max_grade, len(P_s)) + "\n")
    out_f.write(r"};" + "\n")
    out_f.write(r"\end{axis}" + "\n")
    out_f.write(r"\end{tikzpicture}" + "\n")
    out_f.write(r"\end{center}" + "\n")

def write_stats_tex_question_answers(out_f, r_a_QVA, r_na_QV, n_s_QV, P, P_s, P_sQ, e, Q, V, P_sq):
    (N_Q, N_V, N_A) = P.shape
    N_s = P_s.shape[0]

    s = range(N_s)
    s.sort(key=lambda i: P_s[i])
    s = np.array(s, dtype=int)
    X = np.zeros((N_s, N_Q), dtype=int)
    for ri in range(N_s):
        for Qi in range(N_Q):
            if P_sQ[s[ri], Qi] > 0:
                X[ri,Qi] = 1

    n_sb_rQ = np.zeros((N_s, N_Q), dtype=int)
    n_sa_rQ = np.zeros((N_s, N_Q), dtype=int)
    for ri in range(N_s):
        for Qi in range(N_Q):
            n_sb_rQ[ri,Qi] = X[:ri,Qi].sum()
            n_sa_rQ[ri,Qi] = X[ri:,Qi].sum()

    acc_rQ = np.zeros((N_s, N_Q))
    sens_rQ = np.zeros((N_s, N_Q))
    spec_rQ = np.zeros((N_s, N_Q))
    for ri in range(N_s):
        for Qi in range(N_Q):
            acc_rQ[ri,Qi] = (n_sa_rQ[ri,Qi] + ri - 1 - n_sb_rQ[ri,Qi]) / float(N_s)
            sens_rQ[ri,Qi] = n_sa_rQ[ri,Qi] / float(X[:,Qi].sum())
            spec_rQ[ri,Qi] = (ri - 1 - n_sb_rQ[ri,Qi]) / float(N_s - X[:,Qi].sum())

    N_g = 5
    g = np.zeros(N_s, int)
    for si in range(N_s):
        g[s[si]] = int(si / float(N_s) * N_g)

    n_s_g = np.zeros(N_g, int)
    for si in range(N_s):
        n_s_g[g[si]] += 1

    P_gQV = np.zeros((N_g, N_Q, N_V))
    for si in range(N_s):
        for qi in range(N_Q):
            ei = e[si]
            Qi = Q[ei,qi]
            Vi = V[ei,qi]
            gi = g[si]
            if ei >= 0 and Qi >= 0 and Vi >= 0:
                P_gQV[gi,Qi,Vi] += P_sq[si,qi]

    P_gQ = P_gQV.sum(axis=2)

    Pbar_gQ = np.zeros((N_g, N_Q))
    for gi in range(N_g):
        for Qi in range(N_Q):
            Pbar_gQ[gi,Qi] = P_gQ[gi,Qi] / n_s_g[gi]

    Pmax_QV = P.max(axis=2)
    Pmax_Q = Pmax_QV.max(axis=1)

    Pbar_norm_gQ = np.zeros((N_g, N_Q))
    for gi in range(N_g):
        for Qi in range(N_Q):
            Pbar_norm_gQ[gi,Qi] = Pbar_gQ[gi,Qi] / Pmax_Q[Qi]

    for Qi in range(N_Q):
        out_f.write(r"\vspace{2cm}" + "\n")
        out_f.write(r"\noindent" + "\n")
        out_f.write(r"\begin{minipage}{\textwidth}" + "\n")

        width = 9.5
        out_f.write(r"\begin{tikzpicture}[baseline]" + "\n")
        out_f.write(r"\begin{axis}[" + "\n")
        out_f.write(r"title={Question %d}," % (Qi + 1) + "\n")
        out_f.write(r"ybar, ymin=0, ymax=100," + "\n")
        out_f.write(r"width=%gcm, height=4cm," % width+ "\n")
        out_f.write(r"xlabel={answer}," + "\n")
        out_f.write(r"ylabel={student fraction / \%}," + "\n")
        out_f.write(r"symbolic x coords={A,B,C,D,E,none}," + "\n")
        out_f.write(r"xtick=data," + "\n")
        out_f.write(r"ymajorgrids=true," + "\n")
        out_f.write(r"enlarge x limits=0.12," + "\n")
        out_f.write(r"enlarge y limits={upper,value=0.25}," + "\n")
        out_f.write(r"legend style={at={(1.02,0.5)},anchor=west}," + "\n")
        out_f.write(r"bar width=%gcm," % (width / float(N_A + 1) / float(N_V) / 2) + "\n")
        out_f.write(r"point meta=explicit," + "\n")
        out_f.write(r"nodes near coords={\pgfmathfloatifflags{\pgfplotspointmeta}{0}{}{\pgfmathprintnumber{\pgfplotspointmeta}}}," + "\n")
        out_f.write(r"]" + "\n")
        for Vi in range(N_V):
            if n_s_QV[Qi,Vi] == 0:
                continue
            out_f.write(r"\addplot coordinates {" + "\n")
            for Ai in range(N_A):
                out_f.write(r"(%s,%g) [%g]" % (ind2chr(Ai), r_a_QVA[Qi,Vi,Ai] * 100, P[Qi,Vi,Ai]) + "\n")
            out_f.write(r"(none,%g) [0]" % (r_na_QV[Qi,Vi] * 100) + "\n")
            out_f.write(r"};" + "\n")
        out_f.write(r"\legend{%s};" % ",".join(["V%d" % (Vi + 1) for Vi in range(N_V) if n_s_QV[Qi,Vi] > 0]) + "\n")
        out_f.write(r"\end{axis}" + "\n")
        out_f.write(r"\end{tikzpicture}" + "\n")

        out_f.write(r"\hfill" + "\n")

        width = 4
        out_f.write(r"\begin{tikzpicture}[baseline]" + "\n")
        out_f.write(r"\begin{axis}[" + "\n")
        out_f.write(r"ybar, ymin=0, ymax=100," + "\n")
        out_f.write(r"xmin=1, xmax=%d," % N_g + "\n")
        out_f.write(r"width=%gcm, height=4cm," % width + "\n")
        out_f.write(r"symbolic x coords={%s}," % ",".join(["%d" % (gi + 1) for gi in range(N_g)]) + "\n")
        out_f.write(r"xtick=data," + "\n")
        out_f.write(r"xlabel={ranked group}," + "\n")
        out_f.write(r"ylabel={normalized score / \%}," + "\n")
        out_f.write(r"ymajorgrids=true," + "\n")
        out_f.write(r"enlarge x limits=0.12," + "\n")
        out_f.write(r"bar width=%gcm," % (width / float(N_g) / 3) + "\n")
        out_f.write(r"]" + "\n")
        out_f.write(r"\addplot coordinates {" + "\n")
        for gi in range(N_g):
            out_f.write(r"(%s,%g)" % (gi + 1, Pbar_norm_gQ[gi,Qi] * 100) + "\n")
        out_f.write(r"};" + "\n")
        out_f.write(r"\end{axis}" + "\n")
        out_f.write(r"\end{tikzpicture}" + "\n")
        out_f.write("\n")

        out_f.write(r"\begin{tikzpicture}" + "\n")
        out_f.write(r"\begin{axis}[" + "\n")
        out_f.write(r"ymin=0, ymax=100," + "\n")
        out_f.write(r"no markers," + "\n")
        out_f.write(r"xmajorgrids=true," + "\n")
        out_f.write(r"ymajorgrids=true," + "\n")
        out_f.write(r"enlargelimits=false," + "\n")
        out_f.write(r"width=12cm, height=4cm," + "\n")
        out_f.write(r"xlabel={student perc.\ rank / \%}," + "\n")
        out_f.write(r"ylabel={quantity / \%}," + "\n")
        out_f.write(r"legend style={at={(1.02,0.5)},anchor=west}," + "\n")
        out_f.write(r"]" + "\n")

        out_f.write(r"\addplot coordinates {" + "\n")
        for ri in range(N_s):
            out_f.write(r"(%g,%g)" % ((ri + 1) / float(N_s) * 100, sens_rQ[ri,Qi] * 100) + "\n")
        out_f.write(r"};" + "\n")

        out_f.write(r"\addplot coordinates {" + "\n")
        for ri in range(N_s):
            out_f.write(r"(%g,%g)" % ((ri + 1) / float(N_s) * 100, spec_rQ[ri,Qi] * 100) + "\n")
        out_f.write(r"};" + "\n")

        out_f.write(r"\addplot coordinates {" + "\n")
        for ri in range(N_s):
            out_f.write(r"(%g,%g)" % ((ri + 1) / float(N_s) * 100, acc_rQ[ri,Qi] * 100) + "\n")
        out_f.write(r"};" + "\n")

        out_f.write(r"\legend{sensitivity,specificity,accuracy};" + "\n")
        out_f.write(r"\end{axis}" + "\n")
        out_f.write(r"\end{tikzpicture}" + "\n")

        out_f.write(r"\end{minipage}" + "\n")
        out_f.write("\n")

def write_stats_tex_question_summary(out_f, Pbar_QV, Pbar_Q, P, P_s, P_sQ):
    (N_Q, N_V, N_A) = P.shape
    N_s = P_s.shape[0]

    Pmax_QV = P.max(axis=2)
    Pmax_Q = Pmax_QV.max(axis=1)

    Pbar_norm_Q = Pbar_Q / Pmax_Q

    d_Q = np.zeros(N_Q)
    for Qi in range(N_Q):
        d_Q[Qi] = np.corrcoef(P_sQ[:,Qi], P_s)[0,1]

    out_f.write(r"\begin{tikzpicture}" + "\n")
    out_f.write(r"\begin{axis}[" + "\n")
    out_f.write(r"ybar, ymin=0," + "\n")
    out_f.write(r"xmin=1, xmax=%d," % N_Q + "\n")
    out_f.write(r"width=14cm, height=8cm," + "\n")
    out_f.write(r"xlabel={question number}," + "\n")
    out_f.write(r"ylabel={quantity / \%}," + "\n")
    out_f.write(r"ymajorgrids=true," + "\n")
    out_f.write(r"enlarge x limits=0.02," + "\n")
    out_f.write(r"legend style={at={(0.5,1.02)},anchor=south}," + "\n")
    out_f.write(r"bar width=%gcm," % (14 / float(N_Q) / 2 / 4) + "\n")
    out_f.write(r"]" + "\n")

    out_f.write(r"\addplot coordinates {" + "\n")
    for Qi in range(N_Q):
        out_f.write(r"(%d,%g)" % (Qi + 1, (1 - Pbar_norm_Q[Qi]) * 100) + "\n")
    out_f.write(r"};" + "\n")

    out_f.write(r"\addplot coordinates {" + "\n")
    for Qi in range(N_Q):
        out_f.write(r"(%d,%g)" % (Qi + 1, d_Q[Qi] * 100) + "\n")
    out_f.write(r"};" + "\n")

    out_f.write(r"\legend{difficulty,discrimination};" + "\n")
    out_f.write(r"\end{axis}" + "\n")
    out_f.write(r"\end{tikzpicture}" + "\n")
    out_f.write("\n")

def write_stats_tex_question_summary_scatter(out_f, Pbar_QV, Pbar_Q, P, P_s, P_sQ):
    (N_Q, N_V, N_A) = P.shape
    N_s = P_s.shape[0]

    Pmax_QV = P.max(axis=2)
    Pmax_Q = Pmax_QV.max(axis=1)

    Pbar_norm_Q = Pbar_Q / Pmax_Q

    d_Q = np.zeros(N_Q)
    for Qi in range(N_Q):
        d_Q[Qi] = np.corrcoef(P_sQ[:,Qi], P_s)[0,1]

    out_f.write(r"\begin{tikzpicture}" + "\n")
    out_f.write(r"\begin{axis}[" + "\n")
    out_f.write(r"xmin=0, ymin=0," + "\n")
    out_f.write(r"width=14cm, height=14cm," + "\n")
    out_f.write(r"only marks," + "\n")
    out_f.write(r"xlabel={difficulty / \%}," + "\n")
    out_f.write(r"ylabel={discrimination / \%}," + "\n")
    out_f.write(r"xmajorgrids=true," + "\n")
    out_f.write(r"ymajorgrids=true," + "\n")
    out_f.write(r"nodes near coords," + "\n")
    out_f.write(r"point meta=explicit symbolic," + "\n")
    out_f.write(r"every node near coord/.style={yshift=3}," + "\n")
    out_f.write(r"]" + "\n")

    out_f.write(r"\addplot coordinates {" + "\n")
    for Qi in range(N_Q):
        out_f.write(r"(%g,%g) [%d]" % ((1 - Pbar_norm_Q[Qi]) * 100, d_Q[Qi] * 100, Qi + 1) + "\n")
    out_f.write(r"};" + "\n")

    out_f.write(r"\end{axis}" + "\n")
    out_f.write(r"\end{tikzpicture}" + "\n")
    out_f.write("\n")

def write_stats_tex_variant_summary(out_f, Pbar_QV, Pbar_Q, P, P_s, P_sQ, n_s_QV):
    (N_Q, N_V, N_A) = P.shape
    N_s = P_s.shape[0]

    Pbar_rel_QV = np.zeros((N_Q, N_V))
    for Qi in range(N_Q):
        Pbar_rel_QV[Qi,:] = Pbar_QV[Qi,:] / Pbar_Q[Qi]

    out_f.write(r"\begin{tikzpicture}" + "\n")
    out_f.write(r"\begin{axis}[" + "\n")
    out_f.write(r"only marks," + "\n")
    out_f.write(r"xmin=1, xmax=%d," % N_Q + "\n")
    out_f.write(r"width=13cm, height=8cm," + "\n")
    out_f.write(r"ylabel={relative points awarded / \%}," + "\n")
    out_f.write(r"xlabel={question number}," + "\n")
    out_f.write(r"xmajorgrids=true," + "\n")
    out_f.write(r"ymajorgrids=true," + "\n")
    out_f.write(r"enlarge x limits=0.02," + "\n")
    out_f.write(r"legend style={at={(1.02,0.5)},anchor=west}," + "\n")
    out_f.write(r"]" + "\n")

    for Vi in range(N_V):
        out_f.write(r"\addplot coordinates {" + "\n")
        for Qi in range(N_Q):
            if n_s_QV[Qi,Vi] > 0:
                out_f.write(r"(%d,%g)" % (Qi + 1, Pbar_rel_QV[Qi,Vi] * 100) + "\n")
        out_f.write(r"};" + "\n")

    out_f.write(r"\legend{%s};" % ",".join(["V%d" % (Vi + 1) for Vi in range(N_V)]) + "\n")
    out_f.write(r"\end{axis}" + "\n")
    out_f.write(r"\end{tikzpicture}" + "\n")
    out_f.write("\n")

def write_stats_tex(output_filename, r_a_QVA, r_na_QV, n_s_QV, P_s, P, P_sQ, Pbar_QV, Pbar_Q, e, Q, V, P_sq):
    log_and_print("Writing statistics tex file: %s" % output_filename)
    with open(output_filename, "w") as out_f:
        out_f.write(r"\documentclass{article}" + "\n")
        out_f.write(r"\usepackage[margin=3cm]{geometry}" + "\n")
        out_f.write(r"\usepackage{pgfplots}" + "\n")
        out_f.write(r"\begin{document}" + "\n")
        out_f.write("\n")

        out_f.write(r"\section{Student score distribution}" + "\n")
        out_f.write("\n")
        out_f.write(r"\vspace{1cm}" + "\n")
        tex_write_basic_stats(out_f, P_s, P)
        out_f.write(r"\vspace{1cm}" + "\n")
        tex_write_pdf(out_f, P_s, P)
        out_f.write(r"\vspace{1cm}" + "\n")
        tex_write_cdf(out_f, P_s, P)

        out_f.write(r"\clearpage" + "\n")
        out_f.write(r"\section{Question summary data}" + "\n")
        out_f.write("\n")
        write_stats_tex_question_summary(out_f, Pbar_QV, Pbar_Q, P, P_s, P_sQ)
        out_f.write(r"\vspace{1cm}" + "\n")
        write_stats_tex_question_summary_scatter(out_f, Pbar_QV, Pbar_Q, P, P_s, P_sQ)
        out_f.write(r"\vspace{1cm}" + "\n")
        write_stats_tex_variant_summary(out_f, Pbar_QV, Pbar_Q, P, P_s, P_sQ, n_s_QV)

        out_f.write(r"\clearpage" + "\n")
        out_f.write(r"\section{Question detailed data}" + "\n")
        out_f.write("\n")
        write_stats_tex_question_answers(out_f, r_a_QVA, r_na_QV, n_s_QV, P, P_s, P_sQ, e, Q, V, P_sq)

        out_f.write(r"\end{document}" + "\n")
    log("Successfully completed writing statistics tex file")

def generate_and_write_statistics(output_prefix, P, K, Q, V, A, u, k, a):
    log_and_print("Generating and writing statistics")
    (N_Q, N_V, N_A) = P.shape
    N_s = u.shape[0]
    e = keys_to_exams(K, k, u)

    n_s_e = np.zeros(N_e, dtype=int)
    for ei in range(N_e):
        for si in range(N_s):
            if K[ei] == k[si]:
                n_s_e[ei] += 1
    write_csv(output_prefix + "_n_s_e.csv", ["e", "n_s(e)"], n_s_e)

    n_s_QV = np.zeros((N_Q, N_V), dtype=int)
    for si in range(N_s):
        for qi in range(N_Q):
            ei = e[si]
            Qi = Q[ei,qi]
            Vi = V[ei,qi]
            if ei >= 0 and Qi >= 0 and Vi >= 0:
                n_s_QV[Qi,Vi] += 1
    write_csv(output_prefix + "_n_s_QV.csv", ["Q", "n_s(Q,V=%d)"], n_s_QV)

    n_a_QVA = np.zeros((N_Q, N_V, N_A), dtype=int)
    for si in range(N_s):
        for qi in range(N_Q):
            ei = e[si]
            ai = chr2ind(a[si,qi])
            Ai = chr2ind(A[ei,qi,ai])
            Qi = Q[ei,qi]
            Vi = V[ei,qi]
            if ei >= 0 and Ai >= 0 and Ai >= 0 and Qi >= 0 and Vi >= 0:
                n_a_QVA[Qi,Vi,Ai] += 1
    write_csv(output_prefix + "_n_a_QVA.csv", ["Q", "V", "n_a(Q,V,A=%s)"], n_a_QVA,
              index_formats=['i', 'i', 'c'])

    n_a_QV = n_a_QVA.sum(axis=2)
    write_csv(output_prefix + "_n_a_QV.csv", ["Q", "n_a(Q,V=%d)"], n_a_QV)

    n_na_QV = n_s_QV - n_a_QV
    write_csv(output_prefix + "_n_na_QV.csv", ["Q", "n_na(Q,V=%d)"], n_na_QV)

    n_a_Q = n_a_QV.sum(axis=1)
    write_csv(output_prefix + "_n_a_Q.csv", ["Q", "n_a(Q)"], n_a_Q)

    r_a_QVA = np.zeros((N_Q, N_V, N_A))
    for Qi in range(N_Q):
        for Vi in range(N_V):
            r_a_QVA[Qi,Vi,:] = n_a_QVA[Qi,Vi,:] / float(max(1, n_s_QV[Qi,Vi]))
    write_csv(output_prefix + "_r_a_QVA.csv", ["Q", "V", "r_a(Q,V,A=%s)"], n_a_QVA,
              index_formats=['i', 'i', 'c'])

    r_na_QV = np.zeros((N_Q, N_V))
    for Qi in range(N_Q):
        for Vi in range(N_V):
            r_na_QV[Qi,Vi] = n_na_QV[Qi,Vi] / float(max(1, n_s_QV[Qi,Vi]))
    write_csv(output_prefix + "_r_na_QV.csv", ["Q", "r_na(Q,V=%d)"], n_na_QV)

    (P_seq, P_se, P_sq, P_s, P_sQ) = generate_grades(P, K, Q, V, A, u, k, a)

    P_QV = np.zeros((N_Q, N_V))
    for si in range(N_s):
        for qi in range(N_Q):
            ei = e[si]
            Qi = Q[ei,qi]
            Vi = V[ei,qi]
            if ei >= 0 and Qi >= 0 and Vi >= 0:
                P_QV[Qi,Vi] += P_sq[si,qi]
    write_csv(output_prefix + "_P_QV.csv", ["Q", "P(Q,V=%d)"], P_QV)

    P_Q = P_QV.sum(axis=1)
    write_csv(output_prefix + "_P_Q.csv", ["Q", "P(Q)"], P_Q)

    Pbar_QV = P_QV / np.where(n_s_QV > 0, n_s_QV, 1)
    write_csv(output_prefix + "_Pbar_QV.csv", ["Q", "Pbar(Q,V=%d)"], Pbar_QV)

    Pbar_Q = P_Q / N_s
    write_csv(output_prefix + "_Pbar_Q.csv", ["Q", "Pbar(Q)"], Pbar_Q)

    R_QV = np.zeros((N_Q, N_V))
    for Qi in range(N_Q):
        R_QV[Qi,:] = Pbar_QV[Qi,:] / (Pbar_Q[Qi] if Pbar_Q[Qi] != 0 else 1)
    write_csv(output_prefix + "_R_QV.csv", ["Q", "R(Q,V=%d)"], R_QV)

    R_QV_threshold_high = 1.2
    R_QV_threshold_low = 0.8
    for Qi in range(N_Q):
        for Vi in range(N_V):
            if n_s_QV[Qi,Vi] > 0:
                if R_QV[Qi,Vi] > R_QV_threshold_high:
                    log_and_print("WARNING: R_QV(Q=%d,V=%d) = %f is unusually high"
                                  % (Qi + 1, Vi + 1, R_QV[Qi,Vi]))
                if R_QV[Qi,Vi] < R_QV_threshold_low:
                    log_and_print("WARNING: R_QV(Q=%d,V=%d) = %f is unusually low"
                                  % (Qi + 1, Vi + 1, R_QV[Qi,Vi]))

    r_s_QQ = np.corrcoef(P_sQ.transpose())
    write_csv(output_prefix + "_r_s_QQ.csv", ["Q1", "r_s(Q1,Q2=%d)"], r_s_QQ)
    write_halfviz(output_prefix + "_r_s_QQ.halfviz", r_s_QQ, 0.2)

    r_Q_ss = np.corrcoef(P_sQ)
    write_csv(output_prefix + "_r_Q_ss.csv", ["s1", "r_Q(s1,s2=%d)"], r_Q_ss)
    write_halfviz(output_prefix + "_r_Q_ss.halfviz", r_Q_ss, 0.99)

    n_ai_ss = np.zeros((N_s, N_s), dtype=int)
    for si in range(N_s):
        for sj in range(N_s):
            for qi in range(N_Q):
                if P_sq[si,qi] == 0 and P_sq[sj,qi] == 0:
                    n_ai_ss[si,sj] += 1
    write_csv(output_prefix + "_n_ai_ss.csv", ["s1", "n_ai(s1,s2=%d)"], n_ai_ss)

    r_ai_ss = np.zeros((N_s, N_s), dtype=float)
    for si in range(N_s):
        for sj in range(N_s):
            for qi in range(N_Q):
                if P_sq[si,qi] == 0 and P_sq[sj,qi] == 0 and a[si,qi] == a[sj,qi]:
                    r_ai_ss[si,sj] += 1
    r_ai_ss /= np.where(n_ai_ss > 0, n_ai_ss, 1)
    write_csv(output_prefix + "_r_ai_ss.csv", ["s1", "r_ai(s1,s2=%d)"], r_ai_ss)

    r_ai_ss_threshold = 2.0 / N_A
    n_ai_ss_threshold = 2
    for si in range(N_s):
        for sj in range(si):
            if e[si] >= 0 and e[si] == e[sj] \
                    and r_ai_ss[si,sj] > r_ai_ss_threshold \
                    and n_ai_ss[si,sj] > n_ai_ss_threshold:
                log_and_print("WARNING: r_ai_ss(s1=%d,s2=%d) = %f too high, with n_ai_ss(s1=%d,s2=%d) = %d"
                              % (si + 1, sj + 1, r_ai_ss[si,sj], si + 1, sj + 1, n_ai_ss[si,sj]))

    write_stats_tex(output_prefix + ".tex", r_a_QVA, r_na_QV, n_s_QV, P_s, P, P_sQ, Pbar_QV, Pbar_Q, e, Q, V, P_sq)

    log("Successfully completed generating and writing statistics")

######################################################################
######################################################################

if __name__ == "__main__":
    main()
